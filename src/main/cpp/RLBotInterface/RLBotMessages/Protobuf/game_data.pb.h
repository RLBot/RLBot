// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game_data.proto

#ifndef PROTOBUF_game_5fdata_2eproto__INCLUDED
#define PROTOBUF_game_5fdata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace rlbot {
namespace api {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_game_5fdata_2eproto();
void protobuf_AssignDesc_game_5fdata_2eproto();
void protobuf_ShutdownFile_game_5fdata_2eproto();

class ControllerState;
class PlayerInput;
class Vector3;
class Rotator;
class Touch;
class ScoreInfo;
class PlayerInfo;
class BallInfo;
class BoostInfo;
class GameInfo;
class GameTickPacket;

// ===================================================================

class ControllerState : public ::google::protobuf::Message {
 public:
  ControllerState();
  virtual ~ControllerState();

  ControllerState(const ControllerState& from);

  inline ControllerState& operator=(const ControllerState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerState& default_instance();

  void Swap(ControllerState* other);

  // implements Message ----------------------------------------------

  ControllerState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControllerState& from);
  void MergeFrom(const ControllerState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float throttle = 1;
  inline bool has_throttle() const;
  inline void clear_throttle();
  static const int kThrottleFieldNumber = 1;
  inline float throttle() const;
  inline void set_throttle(float value);

  // required float steer = 2;
  inline bool has_steer() const;
  inline void clear_steer();
  static const int kSteerFieldNumber = 2;
  inline float steer() const;
  inline void set_steer(float value);

  // required float pitch = 3;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 3;
  inline float pitch() const;
  inline void set_pitch(float value);

  // required float yaw = 4;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 4;
  inline float yaw() const;
  inline void set_yaw(float value);

  // required float roll = 5;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 5;
  inline float roll() const;
  inline void set_roll(float value);

  // required bool jump = 6;
  inline bool has_jump() const;
  inline void clear_jump();
  static const int kJumpFieldNumber = 6;
  inline bool jump() const;
  inline void set_jump(bool value);

  // required bool boost = 7;
  inline bool has_boost() const;
  inline void clear_boost();
  static const int kBoostFieldNumber = 7;
  inline bool boost() const;
  inline void set_boost(bool value);

  // required bool handbrake = 8;
  inline bool has_handbrake() const;
  inline void clear_handbrake();
  static const int kHandbrakeFieldNumber = 8;
  inline bool handbrake() const;
  inline void set_handbrake(bool value);

  // @@protoc_insertion_point(class_scope:rlbot.api.ControllerState)
 private:
  inline void set_has_throttle();
  inline void clear_has_throttle();
  inline void set_has_steer();
  inline void clear_has_steer();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_jump();
  inline void clear_has_jump();
  inline void set_has_boost();
  inline void clear_has_boost();
  inline void set_has_handbrake();
  inline void clear_has_handbrake();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float throttle_;
  float steer_;
  float pitch_;
  float yaw_;
  float roll_;
  bool jump_;
  bool boost_;
  bool handbrake_;
  friend void  protobuf_AddDesc_game_5fdata_2eproto();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
  static ControllerState* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInput : public ::google::protobuf::Message {
 public:
  PlayerInput();
  virtual ~PlayerInput();

  PlayerInput(const PlayerInput& from);

  inline PlayerInput& operator=(const PlayerInput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInput& default_instance();

  void Swap(PlayerInput* other);

  // implements Message ----------------------------------------------

  PlayerInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInput& from);
  void MergeFrom(const PlayerInput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 player_index = 1;
  inline bool has_player_index() const;
  inline void clear_player_index();
  static const int kPlayerIndexFieldNumber = 1;
  inline ::google::protobuf::int32 player_index() const;
  inline void set_player_index(::google::protobuf::int32 value);

  // required .rlbot.api.ControllerState controller_state = 2;
  inline bool has_controller_state() const;
  inline void clear_controller_state();
  static const int kControllerStateFieldNumber = 2;
  inline const ::rlbot::api::ControllerState& controller_state() const;
  inline ::rlbot::api::ControllerState* mutable_controller_state();
  inline ::rlbot::api::ControllerState* release_controller_state();
  inline void set_allocated_controller_state(::rlbot::api::ControllerState* controller_state);

  // @@protoc_insertion_point(class_scope:rlbot.api.PlayerInput)
 private:
  inline void set_has_player_index();
  inline void clear_has_player_index();
  inline void set_has_controller_state();
  inline void clear_has_controller_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::rlbot::api::ControllerState* controller_state_;
  ::google::protobuf::int32 player_index_;
  friend void  protobuf_AddDesc_game_5fdata_2eproto();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
  static PlayerInput* default_instance_;
};
// -------------------------------------------------------------------

class Vector3 : public ::google::protobuf::Message {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  void Swap(Vector3* other);

  // implements Message ----------------------------------------------

  Vector3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:rlbot.api.Vector3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_game_5fdata_2eproto();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
  static Vector3* default_instance_;
};
// -------------------------------------------------------------------

class Rotator : public ::google::protobuf::Message {
 public:
  Rotator();
  virtual ~Rotator();

  Rotator(const Rotator& from);

  inline Rotator& operator=(const Rotator& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rotator& default_instance();

  void Swap(Rotator* other);

  // implements Message ----------------------------------------------

  Rotator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rotator& from);
  void MergeFrom(const Rotator& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float pitch = 1;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 1;
  inline float pitch() const;
  inline void set_pitch(float value);

  // required float yaw = 2;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 2;
  inline float yaw() const;
  inline void set_yaw(float value);

  // required float roll = 3;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 3;
  inline float roll() const;
  inline void set_roll(float value);

  // @@protoc_insertion_point(class_scope:rlbot.api.Rotator)
 private:
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_roll();
  inline void clear_has_roll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float pitch_;
  float yaw_;
  float roll_;
  friend void  protobuf_AddDesc_game_5fdata_2eproto();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
  static Rotator* default_instance_;
};
// -------------------------------------------------------------------

class Touch : public ::google::protobuf::Message {
 public:
  Touch();
  virtual ~Touch();

  Touch(const Touch& from);

  inline Touch& operator=(const Touch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Touch& default_instance();

  void Swap(Touch* other);

  // implements Message ----------------------------------------------

  Touch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Touch& from);
  void MergeFrom(const Touch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string player_name = 1;
  inline bool has_player_name() const;
  inline void clear_player_name();
  static const int kPlayerNameFieldNumber = 1;
  inline const ::std::string& player_name() const;
  inline void set_player_name(const ::std::string& value);
  inline void set_player_name(const char* value);
  inline void set_player_name(const char* value, size_t size);
  inline ::std::string* mutable_player_name();
  inline ::std::string* release_player_name();
  inline void set_allocated_player_name(::std::string* player_name);

  // required float game_seconds = 2;
  inline bool has_game_seconds() const;
  inline void clear_game_seconds();
  static const int kGameSecondsFieldNumber = 2;
  inline float game_seconds() const;
  inline void set_game_seconds(float value);

  // required .rlbot.api.Vector3 location = 3;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 3;
  inline const ::rlbot::api::Vector3& location() const;
  inline ::rlbot::api::Vector3* mutable_location();
  inline ::rlbot::api::Vector3* release_location();
  inline void set_allocated_location(::rlbot::api::Vector3* location);

  // required .rlbot.api.Vector3 normal = 4;
  inline bool has_normal() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 4;
  inline const ::rlbot::api::Vector3& normal() const;
  inline ::rlbot::api::Vector3* mutable_normal();
  inline ::rlbot::api::Vector3* release_normal();
  inline void set_allocated_normal(::rlbot::api::Vector3* normal);

  // @@protoc_insertion_point(class_scope:rlbot.api.Touch)
 private:
  inline void set_has_player_name();
  inline void clear_has_player_name();
  inline void set_has_game_seconds();
  inline void clear_has_game_seconds();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_normal();
  inline void clear_has_normal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* player_name_;
  ::rlbot::api::Vector3* location_;
  ::rlbot::api::Vector3* normal_;
  float game_seconds_;
  friend void  protobuf_AddDesc_game_5fdata_2eproto();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
  static Touch* default_instance_;
};
// -------------------------------------------------------------------

class ScoreInfo : public ::google::protobuf::Message {
 public:
  ScoreInfo();
  virtual ~ScoreInfo();

  ScoreInfo(const ScoreInfo& from);

  inline ScoreInfo& operator=(const ScoreInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScoreInfo& default_instance();

  void Swap(ScoreInfo* other);

  // implements Message ----------------------------------------------

  ScoreInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScoreInfo& from);
  void MergeFrom(const ScoreInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 score = 1;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 1;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // required int32 goals = 2;
  inline bool has_goals() const;
  inline void clear_goals();
  static const int kGoalsFieldNumber = 2;
  inline ::google::protobuf::int32 goals() const;
  inline void set_goals(::google::protobuf::int32 value);

  // required int32 own_goals = 3;
  inline bool has_own_goals() const;
  inline void clear_own_goals();
  static const int kOwnGoalsFieldNumber = 3;
  inline ::google::protobuf::int32 own_goals() const;
  inline void set_own_goals(::google::protobuf::int32 value);

  // required int32 assists = 4;
  inline bool has_assists() const;
  inline void clear_assists();
  static const int kAssistsFieldNumber = 4;
  inline ::google::protobuf::int32 assists() const;
  inline void set_assists(::google::protobuf::int32 value);

  // required int32 saves = 5;
  inline bool has_saves() const;
  inline void clear_saves();
  static const int kSavesFieldNumber = 5;
  inline ::google::protobuf::int32 saves() const;
  inline void set_saves(::google::protobuf::int32 value);

  // required int32 shots = 6;
  inline bool has_shots() const;
  inline void clear_shots();
  static const int kShotsFieldNumber = 6;
  inline ::google::protobuf::int32 shots() const;
  inline void set_shots(::google::protobuf::int32 value);

  // required int32 demolitions = 7;
  inline bool has_demolitions() const;
  inline void clear_demolitions();
  static const int kDemolitionsFieldNumber = 7;
  inline ::google::protobuf::int32 demolitions() const;
  inline void set_demolitions(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rlbot.api.ScoreInfo)
 private:
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_goals();
  inline void clear_has_goals();
  inline void set_has_own_goals();
  inline void clear_has_own_goals();
  inline void set_has_assists();
  inline void clear_has_assists();
  inline void set_has_saves();
  inline void clear_has_saves();
  inline void set_has_shots();
  inline void clear_has_shots();
  inline void set_has_demolitions();
  inline void clear_has_demolitions();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 goals_;
  ::google::protobuf::int32 own_goals_;
  ::google::protobuf::int32 assists_;
  ::google::protobuf::int32 saves_;
  ::google::protobuf::int32 shots_;
  ::google::protobuf::int32 demolitions_;
  friend void  protobuf_AddDesc_game_5fdata_2eproto();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
  static ScoreInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfo : public ::google::protobuf::Message {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfo& default_instance();

  void Swap(PlayerInfo* other);

  // implements Message ----------------------------------------------

  PlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .rlbot.api.Vector3 location = 1;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 1;
  inline const ::rlbot::api::Vector3& location() const;
  inline ::rlbot::api::Vector3* mutable_location();
  inline ::rlbot::api::Vector3* release_location();
  inline void set_allocated_location(::rlbot::api::Vector3* location);

  // required .rlbot.api.Rotator rotation = 2;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 2;
  inline const ::rlbot::api::Rotator& rotation() const;
  inline ::rlbot::api::Rotator* mutable_rotation();
  inline ::rlbot::api::Rotator* release_rotation();
  inline void set_allocated_rotation(::rlbot::api::Rotator* rotation);

  // required .rlbot.api.Vector3 velocity = 3;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  inline const ::rlbot::api::Vector3& velocity() const;
  inline ::rlbot::api::Vector3* mutable_velocity();
  inline ::rlbot::api::Vector3* release_velocity();
  inline void set_allocated_velocity(::rlbot::api::Vector3* velocity);

  // required .rlbot.api.Vector3 angular_velocity = 4;
  inline bool has_angular_velocity() const;
  inline void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 4;
  inline const ::rlbot::api::Vector3& angular_velocity() const;
  inline ::rlbot::api::Vector3* mutable_angular_velocity();
  inline ::rlbot::api::Vector3* release_angular_velocity();
  inline void set_allocated_angular_velocity(::rlbot::api::Vector3* angular_velocity);

  // required .rlbot.api.ScoreInfo score_info = 5;
  inline bool has_score_info() const;
  inline void clear_score_info();
  static const int kScoreInfoFieldNumber = 5;
  inline const ::rlbot::api::ScoreInfo& score_info() const;
  inline ::rlbot::api::ScoreInfo* mutable_score_info();
  inline ::rlbot::api::ScoreInfo* release_score_info();
  inline void set_allocated_score_info(::rlbot::api::ScoreInfo* score_info);

  // required bool is_demolished = 6;
  inline bool has_is_demolished() const;
  inline void clear_is_demolished();
  static const int kIsDemolishedFieldNumber = 6;
  inline bool is_demolished() const;
  inline void set_is_demolished(bool value);

  // required bool is_midair = 7;
  inline bool has_is_midair() const;
  inline void clear_is_midair();
  static const int kIsMidairFieldNumber = 7;
  inline bool is_midair() const;
  inline void set_is_midair(bool value);

  // required bool is_supersonic = 8;
  inline bool has_is_supersonic() const;
  inline void clear_is_supersonic();
  static const int kIsSupersonicFieldNumber = 8;
  inline bool is_supersonic() const;
  inline void set_is_supersonic(bool value);

  // required bool is_bot = 9;
  inline bool has_is_bot() const;
  inline void clear_is_bot();
  static const int kIsBotFieldNumber = 9;
  inline bool is_bot() const;
  inline void set_is_bot(bool value);

  // required bool jumped = 10;
  inline bool has_jumped() const;
  inline void clear_jumped();
  static const int kJumpedFieldNumber = 10;
  inline bool jumped() const;
  inline void set_jumped(bool value);

  // required bool double_jumped = 11;
  inline bool has_double_jumped() const;
  inline void clear_double_jumped();
  static const int kDoubleJumpedFieldNumber = 11;
  inline bool double_jumped() const;
  inline void set_double_jumped(bool value);

  // required string name = 12;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 12;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 team = 13;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 13;
  inline ::google::protobuf::int32 team() const;
  inline void set_team(::google::protobuf::int32 value);

  // required int32 boost = 14;
  inline bool has_boost() const;
  inline void clear_boost();
  static const int kBoostFieldNumber = 14;
  inline ::google::protobuf::int32 boost() const;
  inline void set_boost(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rlbot.api.PlayerInfo)
 private:
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_angular_velocity();
  inline void clear_has_angular_velocity();
  inline void set_has_score_info();
  inline void clear_has_score_info();
  inline void set_has_is_demolished();
  inline void clear_has_is_demolished();
  inline void set_has_is_midair();
  inline void clear_has_is_midair();
  inline void set_has_is_supersonic();
  inline void clear_has_is_supersonic();
  inline void set_has_is_bot();
  inline void clear_has_is_bot();
  inline void set_has_jumped();
  inline void clear_has_jumped();
  inline void set_has_double_jumped();
  inline void clear_has_double_jumped();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_boost();
  inline void clear_has_boost();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::rlbot::api::Vector3* location_;
  ::rlbot::api::Rotator* rotation_;
  ::rlbot::api::Vector3* velocity_;
  ::rlbot::api::Vector3* angular_velocity_;
  ::rlbot::api::ScoreInfo* score_info_;
  bool is_demolished_;
  bool is_midair_;
  bool is_supersonic_;
  bool is_bot_;
  bool jumped_;
  bool double_jumped_;
  ::std::string* name_;
  ::google::protobuf::int32 team_;
  ::google::protobuf::int32 boost_;
  friend void  protobuf_AddDesc_game_5fdata_2eproto();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
  static PlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class BallInfo : public ::google::protobuf::Message {
 public:
  BallInfo();
  virtual ~BallInfo();

  BallInfo(const BallInfo& from);

  inline BallInfo& operator=(const BallInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BallInfo& default_instance();

  void Swap(BallInfo* other);

  // implements Message ----------------------------------------------

  BallInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BallInfo& from);
  void MergeFrom(const BallInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .rlbot.api.Vector3 location = 1;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 1;
  inline const ::rlbot::api::Vector3& location() const;
  inline ::rlbot::api::Vector3* mutable_location();
  inline ::rlbot::api::Vector3* release_location();
  inline void set_allocated_location(::rlbot::api::Vector3* location);

  // required .rlbot.api.Rotator rotation = 2;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 2;
  inline const ::rlbot::api::Rotator& rotation() const;
  inline ::rlbot::api::Rotator* mutable_rotation();
  inline ::rlbot::api::Rotator* release_rotation();
  inline void set_allocated_rotation(::rlbot::api::Rotator* rotation);

  // required .rlbot.api.Vector3 velocity = 3;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  inline const ::rlbot::api::Vector3& velocity() const;
  inline ::rlbot::api::Vector3* mutable_velocity();
  inline ::rlbot::api::Vector3* release_velocity();
  inline void set_allocated_velocity(::rlbot::api::Vector3* velocity);

  // required .rlbot.api.Vector3 angular_velocity = 4;
  inline bool has_angular_velocity() const;
  inline void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 4;
  inline const ::rlbot::api::Vector3& angular_velocity() const;
  inline ::rlbot::api::Vector3* mutable_angular_velocity();
  inline ::rlbot::api::Vector3* release_angular_velocity();
  inline void set_allocated_angular_velocity(::rlbot::api::Vector3* angular_velocity);

  // required .rlbot.api.Vector3 acceleration = 5;
  inline bool has_acceleration() const;
  inline void clear_acceleration();
  static const int kAccelerationFieldNumber = 5;
  inline const ::rlbot::api::Vector3& acceleration() const;
  inline ::rlbot::api::Vector3* mutable_acceleration();
  inline ::rlbot::api::Vector3* release_acceleration();
  inline void set_allocated_acceleration(::rlbot::api::Vector3* acceleration);

  // required .rlbot.api.Touch latest_touch = 6;
  inline bool has_latest_touch() const;
  inline void clear_latest_touch();
  static const int kLatestTouchFieldNumber = 6;
  inline const ::rlbot::api::Touch& latest_touch() const;
  inline ::rlbot::api::Touch* mutable_latest_touch();
  inline ::rlbot::api::Touch* release_latest_touch();
  inline void set_allocated_latest_touch(::rlbot::api::Touch* latest_touch);

  // @@protoc_insertion_point(class_scope:rlbot.api.BallInfo)
 private:
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_angular_velocity();
  inline void clear_has_angular_velocity();
  inline void set_has_acceleration();
  inline void clear_has_acceleration();
  inline void set_has_latest_touch();
  inline void clear_has_latest_touch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::rlbot::api::Vector3* location_;
  ::rlbot::api::Rotator* rotation_;
  ::rlbot::api::Vector3* velocity_;
  ::rlbot::api::Vector3* angular_velocity_;
  ::rlbot::api::Vector3* acceleration_;
  ::rlbot::api::Touch* latest_touch_;
  friend void  protobuf_AddDesc_game_5fdata_2eproto();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
  static BallInfo* default_instance_;
};
// -------------------------------------------------------------------

class BoostInfo : public ::google::protobuf::Message {
 public:
  BoostInfo();
  virtual ~BoostInfo();

  BoostInfo(const BoostInfo& from);

  inline BoostInfo& operator=(const BoostInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoostInfo& default_instance();

  void Swap(BoostInfo* other);

  // implements Message ----------------------------------------------

  BoostInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoostInfo& from);
  void MergeFrom(const BoostInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .rlbot.api.Vector3 location = 1;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 1;
  inline const ::rlbot::api::Vector3& location() const;
  inline ::rlbot::api::Vector3* mutable_location();
  inline ::rlbot::api::Vector3* release_location();
  inline void set_allocated_location(::rlbot::api::Vector3* location);

  // required bool is_active = 2;
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 2;
  inline bool is_active() const;
  inline void set_is_active(bool value);

  // required float timer = 3;
  inline bool has_timer() const;
  inline void clear_timer();
  static const int kTimerFieldNumber = 3;
  inline float timer() const;
  inline void set_timer(float value);

  // @@protoc_insertion_point(class_scope:rlbot.api.BoostInfo)
 private:
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_is_active();
  inline void clear_has_is_active();
  inline void set_has_timer();
  inline void clear_has_timer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::rlbot::api::Vector3* location_;
  bool is_active_;
  float timer_;
  friend void  protobuf_AddDesc_game_5fdata_2eproto();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
  static BoostInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();

  void Swap(GameInfo* other);

  // implements Message ----------------------------------------------

  GameInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float seconds_elapsed = 1;
  inline bool has_seconds_elapsed() const;
  inline void clear_seconds_elapsed();
  static const int kSecondsElapsedFieldNumber = 1;
  inline float seconds_elapsed() const;
  inline void set_seconds_elapsed(float value);

  // required float game_time_remaining = 2;
  inline bool has_game_time_remaining() const;
  inline void clear_game_time_remaining();
  static const int kGameTimeRemainingFieldNumber = 2;
  inline float game_time_remaining() const;
  inline void set_game_time_remaining(float value);

  // required bool is_overtime = 3;
  inline bool has_is_overtime() const;
  inline void clear_is_overtime();
  static const int kIsOvertimeFieldNumber = 3;
  inline bool is_overtime() const;
  inline void set_is_overtime(bool value);

  // required bool is_unlimited_time = 4;
  inline bool has_is_unlimited_time() const;
  inline void clear_is_unlimited_time();
  static const int kIsUnlimitedTimeFieldNumber = 4;
  inline bool is_unlimited_time() const;
  inline void set_is_unlimited_time(bool value);

  // required bool is_round_active = 5;
  inline bool has_is_round_active() const;
  inline void clear_is_round_active();
  static const int kIsRoundActiveFieldNumber = 5;
  inline bool is_round_active() const;
  inline void set_is_round_active(bool value);

  // required bool is_kickoff_pause = 6;
  inline bool has_is_kickoff_pause() const;
  inline void clear_is_kickoff_pause();
  static const int kIsKickoffPauseFieldNumber = 6;
  inline bool is_kickoff_pause() const;
  inline void set_is_kickoff_pause(bool value);

  // required bool is_match_ended = 7;
  inline bool has_is_match_ended() const;
  inline void clear_is_match_ended();
  static const int kIsMatchEndedFieldNumber = 7;
  inline bool is_match_ended() const;
  inline void set_is_match_ended(bool value);

  // @@protoc_insertion_point(class_scope:rlbot.api.GameInfo)
 private:
  inline void set_has_seconds_elapsed();
  inline void clear_has_seconds_elapsed();
  inline void set_has_game_time_remaining();
  inline void clear_has_game_time_remaining();
  inline void set_has_is_overtime();
  inline void clear_has_is_overtime();
  inline void set_has_is_unlimited_time();
  inline void clear_has_is_unlimited_time();
  inline void set_has_is_round_active();
  inline void clear_has_is_round_active();
  inline void set_has_is_kickoff_pause();
  inline void clear_has_is_kickoff_pause();
  inline void set_has_is_match_ended();
  inline void clear_has_is_match_ended();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float seconds_elapsed_;
  float game_time_remaining_;
  bool is_overtime_;
  bool is_unlimited_time_;
  bool is_round_active_;
  bool is_kickoff_pause_;
  bool is_match_ended_;
  friend void  protobuf_AddDesc_game_5fdata_2eproto();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
  static GameInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameTickPacket : public ::google::protobuf::Message {
 public:
  GameTickPacket();
  virtual ~GameTickPacket();

  GameTickPacket(const GameTickPacket& from);

  inline GameTickPacket& operator=(const GameTickPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameTickPacket& default_instance();

  void Swap(GameTickPacket* other);

  // implements Message ----------------------------------------------

  GameTickPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameTickPacket& from);
  void MergeFrom(const GameTickPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rlbot.api.PlayerInfo players = 1;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 1;
  inline const ::rlbot::api::PlayerInfo& players(int index) const;
  inline ::rlbot::api::PlayerInfo* mutable_players(int index);
  inline ::rlbot::api::PlayerInfo* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo >*
      mutable_players();

  // required int32 player_index = 2;
  inline bool has_player_index() const;
  inline void clear_player_index();
  static const int kPlayerIndexFieldNumber = 2;
  inline ::google::protobuf::int32 player_index() const;
  inline void set_player_index(::google::protobuf::int32 value);

  // repeated .rlbot.api.BoostInfo boost_pads = 3;
  inline int boost_pads_size() const;
  inline void clear_boost_pads();
  static const int kBoostPadsFieldNumber = 3;
  inline const ::rlbot::api::BoostInfo& boost_pads(int index) const;
  inline ::rlbot::api::BoostInfo* mutable_boost_pads(int index);
  inline ::rlbot::api::BoostInfo* add_boost_pads();
  inline const ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo >&
      boost_pads() const;
  inline ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo >*
      mutable_boost_pads();

  // required .rlbot.api.BallInfo ball = 4;
  inline bool has_ball() const;
  inline void clear_ball();
  static const int kBallFieldNumber = 4;
  inline const ::rlbot::api::BallInfo& ball() const;
  inline ::rlbot::api::BallInfo* mutable_ball();
  inline ::rlbot::api::BallInfo* release_ball();
  inline void set_allocated_ball(::rlbot::api::BallInfo* ball);

  // required .rlbot.api.GameInfo game_info = 5;
  inline bool has_game_info() const;
  inline void clear_game_info();
  static const int kGameInfoFieldNumber = 5;
  inline const ::rlbot::api::GameInfo& game_info() const;
  inline ::rlbot::api::GameInfo* mutable_game_info();
  inline ::rlbot::api::GameInfo* release_game_info();
  inline void set_allocated_game_info(::rlbot::api::GameInfo* game_info);

  // @@protoc_insertion_point(class_scope:rlbot.api.GameTickPacket)
 private:
  inline void set_has_player_index();
  inline void clear_has_player_index();
  inline void set_has_ball();
  inline void clear_has_ball();
  inline void set_has_game_info();
  inline void clear_has_game_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo > players_;
  ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo > boost_pads_;
  ::rlbot::api::BallInfo* ball_;
  ::rlbot::api::GameInfo* game_info_;
  ::google::protobuf::int32 player_index_;
  friend void  protobuf_AddDesc_game_5fdata_2eproto();
  friend void protobuf_AssignDesc_game_5fdata_2eproto();
  friend void protobuf_ShutdownFile_game_5fdata_2eproto();

  void InitAsDefaultInstance();
  static GameTickPacket* default_instance_;
};
// ===================================================================


// ===================================================================

// ControllerState

// required float throttle = 1;
inline bool ControllerState::has_throttle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControllerState::set_has_throttle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControllerState::clear_has_throttle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControllerState::clear_throttle() {
  throttle_ = 0;
  clear_has_throttle();
}
inline float ControllerState::throttle() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.throttle)
  return throttle_;
}
inline void ControllerState::set_throttle(float value) {
  set_has_throttle();
  throttle_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.throttle)
}

// required float steer = 2;
inline bool ControllerState::has_steer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControllerState::set_has_steer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControllerState::clear_has_steer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControllerState::clear_steer() {
  steer_ = 0;
  clear_has_steer();
}
inline float ControllerState::steer() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.steer)
  return steer_;
}
inline void ControllerState::set_steer(float value) {
  set_has_steer();
  steer_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.steer)
}

// required float pitch = 3;
inline bool ControllerState::has_pitch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControllerState::set_has_pitch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControllerState::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControllerState::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float ControllerState::pitch() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.pitch)
  return pitch_;
}
inline void ControllerState::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.pitch)
}

// required float yaw = 4;
inline bool ControllerState::has_yaw() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControllerState::set_has_yaw() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControllerState::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControllerState::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float ControllerState::yaw() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.yaw)
  return yaw_;
}
inline void ControllerState::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.yaw)
}

// required float roll = 5;
inline bool ControllerState::has_roll() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ControllerState::set_has_roll() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ControllerState::clear_has_roll() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ControllerState::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float ControllerState::roll() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.roll)
  return roll_;
}
inline void ControllerState::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.roll)
}

// required bool jump = 6;
inline bool ControllerState::has_jump() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ControllerState::set_has_jump() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ControllerState::clear_has_jump() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ControllerState::clear_jump() {
  jump_ = false;
  clear_has_jump();
}
inline bool ControllerState::jump() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.jump)
  return jump_;
}
inline void ControllerState::set_jump(bool value) {
  set_has_jump();
  jump_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.jump)
}

// required bool boost = 7;
inline bool ControllerState::has_boost() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ControllerState::set_has_boost() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ControllerState::clear_has_boost() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ControllerState::clear_boost() {
  boost_ = false;
  clear_has_boost();
}
inline bool ControllerState::boost() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.boost)
  return boost_;
}
inline void ControllerState::set_boost(bool value) {
  set_has_boost();
  boost_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.boost)
}

// required bool handbrake = 8;
inline bool ControllerState::has_handbrake() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ControllerState::set_has_handbrake() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ControllerState::clear_has_handbrake() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ControllerState::clear_handbrake() {
  handbrake_ = false;
  clear_has_handbrake();
}
inline bool ControllerState::handbrake() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.handbrake)
  return handbrake_;
}
inline void ControllerState::set_handbrake(bool value) {
  set_has_handbrake();
  handbrake_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.handbrake)
}

// -------------------------------------------------------------------

// PlayerInput

// required int32 player_index = 1;
inline bool PlayerInput::has_player_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInput::set_has_player_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInput::clear_has_player_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInput::clear_player_index() {
  player_index_ = 0;
  clear_has_player_index();
}
inline ::google::protobuf::int32 PlayerInput::player_index() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInput.player_index)
  return player_index_;
}
inline void PlayerInput::set_player_index(::google::protobuf::int32 value) {
  set_has_player_index();
  player_index_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInput.player_index)
}

// required .rlbot.api.ControllerState controller_state = 2;
inline bool PlayerInput::has_controller_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInput::set_has_controller_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInput::clear_has_controller_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInput::clear_controller_state() {
  if (controller_state_ != NULL) controller_state_->::rlbot::api::ControllerState::Clear();
  clear_has_controller_state();
}
inline const ::rlbot::api::ControllerState& PlayerInput::controller_state() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInput.controller_state)
  return controller_state_ != NULL ? *controller_state_ : *default_instance_->controller_state_;
}
inline ::rlbot::api::ControllerState* PlayerInput::mutable_controller_state() {
  set_has_controller_state();
  if (controller_state_ == NULL) controller_state_ = new ::rlbot::api::ControllerState;
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInput.controller_state)
  return controller_state_;
}
inline ::rlbot::api::ControllerState* PlayerInput::release_controller_state() {
  clear_has_controller_state();
  ::rlbot::api::ControllerState* temp = controller_state_;
  controller_state_ = NULL;
  return temp;
}
inline void PlayerInput::set_allocated_controller_state(::rlbot::api::ControllerState* controller_state) {
  delete controller_state_;
  controller_state_ = controller_state;
  if (controller_state) {
    set_has_controller_state();
  } else {
    clear_has_controller_state();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInput.controller_state)
}

// -------------------------------------------------------------------

// Vector3

// required float x = 1;
inline bool Vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Vector3.x)
  return x_;
}
inline void Vector3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Vector3.x)
}

// required float y = 2;
inline bool Vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Vector3.y)
  return y_;
}
inline void Vector3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Vector3.y)
}

// required float z = 3;
inline bool Vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Vector3.z)
  return z_;
}
inline void Vector3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Vector3.z)
}

// -------------------------------------------------------------------

// Rotator

// required float pitch = 1;
inline bool Rotator::has_pitch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rotator::set_has_pitch() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rotator::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rotator::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float Rotator::pitch() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Rotator.pitch)
  return pitch_;
}
inline void Rotator::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Rotator.pitch)
}

// required float yaw = 2;
inline bool Rotator::has_yaw() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rotator::set_has_yaw() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rotator::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rotator::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float Rotator::yaw() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Rotator.yaw)
  return yaw_;
}
inline void Rotator::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Rotator.yaw)
}

// required float roll = 3;
inline bool Rotator::has_roll() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rotator::set_has_roll() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rotator::clear_has_roll() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rotator::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float Rotator::roll() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Rotator.roll)
  return roll_;
}
inline void Rotator::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Rotator.roll)
}

// -------------------------------------------------------------------

// Touch

// required string player_name = 1;
inline bool Touch::has_player_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Touch::set_has_player_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Touch::clear_has_player_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Touch::clear_player_name() {
  if (player_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_->clear();
  }
  clear_has_player_name();
}
inline const ::std::string& Touch::player_name() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Touch.player_name)
  return *player_name_;
}
inline void Touch::set_player_name(const ::std::string& value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
  // @@protoc_insertion_point(field_set:rlbot.api.Touch.player_name)
}
inline void Touch::set_player_name(const char* value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:rlbot.api.Touch.player_name)
}
inline void Touch::set_player_name(const char* value, size_t size) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rlbot.api.Touch.player_name)
}
inline ::std::string* Touch::mutable_player_name() {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.Touch.player_name)
  return player_name_;
}
inline ::std::string* Touch::release_player_name() {
  clear_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = player_name_;
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Touch::set_allocated_player_name(::std::string* player_name) {
  if (player_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_name_;
  }
  if (player_name) {
    set_has_player_name();
    player_name_ = player_name;
  } else {
    clear_has_player_name();
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.Touch.player_name)
}

// required float game_seconds = 2;
inline bool Touch::has_game_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Touch::set_has_game_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Touch::clear_has_game_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Touch::clear_game_seconds() {
  game_seconds_ = 0;
  clear_has_game_seconds();
}
inline float Touch::game_seconds() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Touch.game_seconds)
  return game_seconds_;
}
inline void Touch::set_game_seconds(float value) {
  set_has_game_seconds();
  game_seconds_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Touch.game_seconds)
}

// required .rlbot.api.Vector3 location = 3;
inline bool Touch::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Touch::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Touch::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Touch::clear_location() {
  if (location_ != NULL) location_->::rlbot::api::Vector3::Clear();
  clear_has_location();
}
inline const ::rlbot::api::Vector3& Touch::location() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Touch.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::rlbot::api::Vector3* Touch::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::rlbot::api::Vector3;
  // @@protoc_insertion_point(field_mutable:rlbot.api.Touch.location)
  return location_;
}
inline ::rlbot::api::Vector3* Touch::release_location() {
  clear_has_location();
  ::rlbot::api::Vector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline void Touch::set_allocated_location(::rlbot::api::Vector3* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.Touch.location)
}

// required .rlbot.api.Vector3 normal = 4;
inline bool Touch::has_normal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Touch::set_has_normal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Touch::clear_has_normal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Touch::clear_normal() {
  if (normal_ != NULL) normal_->::rlbot::api::Vector3::Clear();
  clear_has_normal();
}
inline const ::rlbot::api::Vector3& Touch::normal() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Touch.normal)
  return normal_ != NULL ? *normal_ : *default_instance_->normal_;
}
inline ::rlbot::api::Vector3* Touch::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) normal_ = new ::rlbot::api::Vector3;
  // @@protoc_insertion_point(field_mutable:rlbot.api.Touch.normal)
  return normal_;
}
inline ::rlbot::api::Vector3* Touch::release_normal() {
  clear_has_normal();
  ::rlbot::api::Vector3* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void Touch::set_allocated_normal(::rlbot::api::Vector3* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.Touch.normal)
}

// -------------------------------------------------------------------

// ScoreInfo

// required int32 score = 1;
inline bool ScoreInfo::has_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScoreInfo::set_has_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScoreInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScoreInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 ScoreInfo::score() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.score)
  return score_;
}
inline void ScoreInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.score)
}

// required int32 goals = 2;
inline bool ScoreInfo::has_goals() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScoreInfo::set_has_goals() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScoreInfo::clear_has_goals() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScoreInfo::clear_goals() {
  goals_ = 0;
  clear_has_goals();
}
inline ::google::protobuf::int32 ScoreInfo::goals() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.goals)
  return goals_;
}
inline void ScoreInfo::set_goals(::google::protobuf::int32 value) {
  set_has_goals();
  goals_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.goals)
}

// required int32 own_goals = 3;
inline bool ScoreInfo::has_own_goals() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScoreInfo::set_has_own_goals() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScoreInfo::clear_has_own_goals() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScoreInfo::clear_own_goals() {
  own_goals_ = 0;
  clear_has_own_goals();
}
inline ::google::protobuf::int32 ScoreInfo::own_goals() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.own_goals)
  return own_goals_;
}
inline void ScoreInfo::set_own_goals(::google::protobuf::int32 value) {
  set_has_own_goals();
  own_goals_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.own_goals)
}

// required int32 assists = 4;
inline bool ScoreInfo::has_assists() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScoreInfo::set_has_assists() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScoreInfo::clear_has_assists() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScoreInfo::clear_assists() {
  assists_ = 0;
  clear_has_assists();
}
inline ::google::protobuf::int32 ScoreInfo::assists() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.assists)
  return assists_;
}
inline void ScoreInfo::set_assists(::google::protobuf::int32 value) {
  set_has_assists();
  assists_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.assists)
}

// required int32 saves = 5;
inline bool ScoreInfo::has_saves() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScoreInfo::set_has_saves() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScoreInfo::clear_has_saves() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScoreInfo::clear_saves() {
  saves_ = 0;
  clear_has_saves();
}
inline ::google::protobuf::int32 ScoreInfo::saves() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.saves)
  return saves_;
}
inline void ScoreInfo::set_saves(::google::protobuf::int32 value) {
  set_has_saves();
  saves_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.saves)
}

// required int32 shots = 6;
inline bool ScoreInfo::has_shots() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScoreInfo::set_has_shots() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScoreInfo::clear_has_shots() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScoreInfo::clear_shots() {
  shots_ = 0;
  clear_has_shots();
}
inline ::google::protobuf::int32 ScoreInfo::shots() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.shots)
  return shots_;
}
inline void ScoreInfo::set_shots(::google::protobuf::int32 value) {
  set_has_shots();
  shots_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.shots)
}

// required int32 demolitions = 7;
inline bool ScoreInfo::has_demolitions() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScoreInfo::set_has_demolitions() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScoreInfo::clear_has_demolitions() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScoreInfo::clear_demolitions() {
  demolitions_ = 0;
  clear_has_demolitions();
}
inline ::google::protobuf::int32 ScoreInfo::demolitions() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.demolitions)
  return demolitions_;
}
inline void ScoreInfo::set_demolitions(::google::protobuf::int32 value) {
  set_has_demolitions();
  demolitions_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.demolitions)
}

// -------------------------------------------------------------------

// PlayerInfo

// required .rlbot.api.Vector3 location = 1;
inline bool PlayerInfo::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfo::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfo::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfo::clear_location() {
  if (location_ != NULL) location_->::rlbot::api::Vector3::Clear();
  clear_has_location();
}
inline const ::rlbot::api::Vector3& PlayerInfo::location() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::rlbot::api::Vector3* PlayerInfo::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::rlbot::api::Vector3;
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.location)
  return location_;
}
inline ::rlbot::api::Vector3* PlayerInfo::release_location() {
  clear_has_location();
  ::rlbot::api::Vector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_location(::rlbot::api::Vector3* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.location)
}

// required .rlbot.api.Rotator rotation = 2;
inline bool PlayerInfo::has_rotation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfo::set_has_rotation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfo::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfo::clear_rotation() {
  if (rotation_ != NULL) rotation_->::rlbot::api::Rotator::Clear();
  clear_has_rotation();
}
inline const ::rlbot::api::Rotator& PlayerInfo::rotation() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.rotation)
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
}
inline ::rlbot::api::Rotator* PlayerInfo::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) rotation_ = new ::rlbot::api::Rotator;
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.rotation)
  return rotation_;
}
inline ::rlbot::api::Rotator* PlayerInfo::release_rotation() {
  clear_has_rotation();
  ::rlbot::api::Rotator* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_rotation(::rlbot::api::Rotator* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.rotation)
}

// required .rlbot.api.Vector3 velocity = 3;
inline bool PlayerInfo::has_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfo::set_has_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInfo::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInfo::clear_velocity() {
  if (velocity_ != NULL) velocity_->::rlbot::api::Vector3::Clear();
  clear_has_velocity();
}
inline const ::rlbot::api::Vector3& PlayerInfo::velocity() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::rlbot::api::Vector3* PlayerInfo::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::rlbot::api::Vector3;
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.velocity)
  return velocity_;
}
inline ::rlbot::api::Vector3* PlayerInfo::release_velocity() {
  clear_has_velocity();
  ::rlbot::api::Vector3* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_velocity(::rlbot::api::Vector3* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.velocity)
}

// required .rlbot.api.Vector3 angular_velocity = 4;
inline bool PlayerInfo::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfo::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerInfo::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerInfo::clear_angular_velocity() {
  if (angular_velocity_ != NULL) angular_velocity_->::rlbot::api::Vector3::Clear();
  clear_has_angular_velocity();
}
inline const ::rlbot::api::Vector3& PlayerInfo::angular_velocity() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.angular_velocity)
  return angular_velocity_ != NULL ? *angular_velocity_ : *default_instance_->angular_velocity_;
}
inline ::rlbot::api::Vector3* PlayerInfo::mutable_angular_velocity() {
  set_has_angular_velocity();
  if (angular_velocity_ == NULL) angular_velocity_ = new ::rlbot::api::Vector3;
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.angular_velocity)
  return angular_velocity_;
}
inline ::rlbot::api::Vector3* PlayerInfo::release_angular_velocity() {
  clear_has_angular_velocity();
  ::rlbot::api::Vector3* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_angular_velocity(::rlbot::api::Vector3* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    set_has_angular_velocity();
  } else {
    clear_has_angular_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.angular_velocity)
}

// required .rlbot.api.ScoreInfo score_info = 5;
inline bool PlayerInfo::has_score_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerInfo::set_has_score_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerInfo::clear_has_score_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerInfo::clear_score_info() {
  if (score_info_ != NULL) score_info_->::rlbot::api::ScoreInfo::Clear();
  clear_has_score_info();
}
inline const ::rlbot::api::ScoreInfo& PlayerInfo::score_info() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.score_info)
  return score_info_ != NULL ? *score_info_ : *default_instance_->score_info_;
}
inline ::rlbot::api::ScoreInfo* PlayerInfo::mutable_score_info() {
  set_has_score_info();
  if (score_info_ == NULL) score_info_ = new ::rlbot::api::ScoreInfo;
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.score_info)
  return score_info_;
}
inline ::rlbot::api::ScoreInfo* PlayerInfo::release_score_info() {
  clear_has_score_info();
  ::rlbot::api::ScoreInfo* temp = score_info_;
  score_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_score_info(::rlbot::api::ScoreInfo* score_info) {
  delete score_info_;
  score_info_ = score_info;
  if (score_info) {
    set_has_score_info();
  } else {
    clear_has_score_info();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.score_info)
}

// required bool is_demolished = 6;
inline bool PlayerInfo::has_is_demolished() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerInfo::set_has_is_demolished() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerInfo::clear_has_is_demolished() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerInfo::clear_is_demolished() {
  is_demolished_ = false;
  clear_has_is_demolished();
}
inline bool PlayerInfo::is_demolished() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.is_demolished)
  return is_demolished_;
}
inline void PlayerInfo::set_is_demolished(bool value) {
  set_has_is_demolished();
  is_demolished_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.is_demolished)
}

// required bool is_midair = 7;
inline bool PlayerInfo::has_is_midair() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerInfo::set_has_is_midair() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerInfo::clear_has_is_midair() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerInfo::clear_is_midair() {
  is_midair_ = false;
  clear_has_is_midair();
}
inline bool PlayerInfo::is_midair() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.is_midair)
  return is_midair_;
}
inline void PlayerInfo::set_is_midair(bool value) {
  set_has_is_midair();
  is_midair_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.is_midair)
}

// required bool is_supersonic = 8;
inline bool PlayerInfo::has_is_supersonic() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerInfo::set_has_is_supersonic() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerInfo::clear_has_is_supersonic() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerInfo::clear_is_supersonic() {
  is_supersonic_ = false;
  clear_has_is_supersonic();
}
inline bool PlayerInfo::is_supersonic() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.is_supersonic)
  return is_supersonic_;
}
inline void PlayerInfo::set_is_supersonic(bool value) {
  set_has_is_supersonic();
  is_supersonic_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.is_supersonic)
}

// required bool is_bot = 9;
inline bool PlayerInfo::has_is_bot() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerInfo::set_has_is_bot() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerInfo::clear_has_is_bot() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerInfo::clear_is_bot() {
  is_bot_ = false;
  clear_has_is_bot();
}
inline bool PlayerInfo::is_bot() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.is_bot)
  return is_bot_;
}
inline void PlayerInfo::set_is_bot(bool value) {
  set_has_is_bot();
  is_bot_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.is_bot)
}

// required bool jumped = 10;
inline bool PlayerInfo::has_jumped() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlayerInfo::set_has_jumped() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlayerInfo::clear_has_jumped() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlayerInfo::clear_jumped() {
  jumped_ = false;
  clear_has_jumped();
}
inline bool PlayerInfo::jumped() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.jumped)
  return jumped_;
}
inline void PlayerInfo::set_jumped(bool value) {
  set_has_jumped();
  jumped_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.jumped)
}

// required bool double_jumped = 11;
inline bool PlayerInfo::has_double_jumped() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlayerInfo::set_has_double_jumped() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlayerInfo::clear_has_double_jumped() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlayerInfo::clear_double_jumped() {
  double_jumped_ = false;
  clear_has_double_jumped();
}
inline bool PlayerInfo::double_jumped() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.double_jumped)
  return double_jumped_;
}
inline void PlayerInfo::set_double_jumped(bool value) {
  set_has_double_jumped();
  double_jumped_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.double_jumped)
}

// required string name = 12;
inline bool PlayerInfo::has_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PlayerInfo::set_has_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PlayerInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PlayerInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.name)
  return *name_;
}
inline void PlayerInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.name)
}
inline void PlayerInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:rlbot.api.PlayerInfo.name)
}
inline void PlayerInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rlbot.api.PlayerInfo.name)
}
inline ::std::string* PlayerInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.name)
  return name_;
}
inline ::std::string* PlayerInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayerInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.name)
}

// required int32 team = 13;
inline bool PlayerInfo::has_team() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PlayerInfo::set_has_team() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PlayerInfo::clear_has_team() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PlayerInfo::clear_team() {
  team_ = 0;
  clear_has_team();
}
inline ::google::protobuf::int32 PlayerInfo::team() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.team)
  return team_;
}
inline void PlayerInfo::set_team(::google::protobuf::int32 value) {
  set_has_team();
  team_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.team)
}

// required int32 boost = 14;
inline bool PlayerInfo::has_boost() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PlayerInfo::set_has_boost() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PlayerInfo::clear_has_boost() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PlayerInfo::clear_boost() {
  boost_ = 0;
  clear_has_boost();
}
inline ::google::protobuf::int32 PlayerInfo::boost() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.boost)
  return boost_;
}
inline void PlayerInfo::set_boost(::google::protobuf::int32 value) {
  set_has_boost();
  boost_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.boost)
}

// -------------------------------------------------------------------

// BallInfo

// required .rlbot.api.Vector3 location = 1;
inline bool BallInfo::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BallInfo::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BallInfo::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BallInfo::clear_location() {
  if (location_ != NULL) location_->::rlbot::api::Vector3::Clear();
  clear_has_location();
}
inline const ::rlbot::api::Vector3& BallInfo::location() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::rlbot::api::Vector3* BallInfo::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::rlbot::api::Vector3;
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.location)
  return location_;
}
inline ::rlbot::api::Vector3* BallInfo::release_location() {
  clear_has_location();
  ::rlbot::api::Vector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline void BallInfo::set_allocated_location(::rlbot::api::Vector3* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.location)
}

// required .rlbot.api.Rotator rotation = 2;
inline bool BallInfo::has_rotation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BallInfo::set_has_rotation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BallInfo::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BallInfo::clear_rotation() {
  if (rotation_ != NULL) rotation_->::rlbot::api::Rotator::Clear();
  clear_has_rotation();
}
inline const ::rlbot::api::Rotator& BallInfo::rotation() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.rotation)
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
}
inline ::rlbot::api::Rotator* BallInfo::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) rotation_ = new ::rlbot::api::Rotator;
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.rotation)
  return rotation_;
}
inline ::rlbot::api::Rotator* BallInfo::release_rotation() {
  clear_has_rotation();
  ::rlbot::api::Rotator* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void BallInfo::set_allocated_rotation(::rlbot::api::Rotator* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.rotation)
}

// required .rlbot.api.Vector3 velocity = 3;
inline bool BallInfo::has_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BallInfo::set_has_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BallInfo::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BallInfo::clear_velocity() {
  if (velocity_ != NULL) velocity_->::rlbot::api::Vector3::Clear();
  clear_has_velocity();
}
inline const ::rlbot::api::Vector3& BallInfo::velocity() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::rlbot::api::Vector3* BallInfo::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::rlbot::api::Vector3;
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.velocity)
  return velocity_;
}
inline ::rlbot::api::Vector3* BallInfo::release_velocity() {
  clear_has_velocity();
  ::rlbot::api::Vector3* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void BallInfo::set_allocated_velocity(::rlbot::api::Vector3* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.velocity)
}

// required .rlbot.api.Vector3 angular_velocity = 4;
inline bool BallInfo::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BallInfo::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BallInfo::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BallInfo::clear_angular_velocity() {
  if (angular_velocity_ != NULL) angular_velocity_->::rlbot::api::Vector3::Clear();
  clear_has_angular_velocity();
}
inline const ::rlbot::api::Vector3& BallInfo::angular_velocity() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.angular_velocity)
  return angular_velocity_ != NULL ? *angular_velocity_ : *default_instance_->angular_velocity_;
}
inline ::rlbot::api::Vector3* BallInfo::mutable_angular_velocity() {
  set_has_angular_velocity();
  if (angular_velocity_ == NULL) angular_velocity_ = new ::rlbot::api::Vector3;
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.angular_velocity)
  return angular_velocity_;
}
inline ::rlbot::api::Vector3* BallInfo::release_angular_velocity() {
  clear_has_angular_velocity();
  ::rlbot::api::Vector3* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline void BallInfo::set_allocated_angular_velocity(::rlbot::api::Vector3* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    set_has_angular_velocity();
  } else {
    clear_has_angular_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.angular_velocity)
}

// required .rlbot.api.Vector3 acceleration = 5;
inline bool BallInfo::has_acceleration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BallInfo::set_has_acceleration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BallInfo::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BallInfo::clear_acceleration() {
  if (acceleration_ != NULL) acceleration_->::rlbot::api::Vector3::Clear();
  clear_has_acceleration();
}
inline const ::rlbot::api::Vector3& BallInfo::acceleration() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.acceleration)
  return acceleration_ != NULL ? *acceleration_ : *default_instance_->acceleration_;
}
inline ::rlbot::api::Vector3* BallInfo::mutable_acceleration() {
  set_has_acceleration();
  if (acceleration_ == NULL) acceleration_ = new ::rlbot::api::Vector3;
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.acceleration)
  return acceleration_;
}
inline ::rlbot::api::Vector3* BallInfo::release_acceleration() {
  clear_has_acceleration();
  ::rlbot::api::Vector3* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline void BallInfo::set_allocated_acceleration(::rlbot::api::Vector3* acceleration) {
  delete acceleration_;
  acceleration_ = acceleration;
  if (acceleration) {
    set_has_acceleration();
  } else {
    clear_has_acceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.acceleration)
}

// required .rlbot.api.Touch latest_touch = 6;
inline bool BallInfo::has_latest_touch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BallInfo::set_has_latest_touch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BallInfo::clear_has_latest_touch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BallInfo::clear_latest_touch() {
  if (latest_touch_ != NULL) latest_touch_->::rlbot::api::Touch::Clear();
  clear_has_latest_touch();
}
inline const ::rlbot::api::Touch& BallInfo::latest_touch() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.latest_touch)
  return latest_touch_ != NULL ? *latest_touch_ : *default_instance_->latest_touch_;
}
inline ::rlbot::api::Touch* BallInfo::mutable_latest_touch() {
  set_has_latest_touch();
  if (latest_touch_ == NULL) latest_touch_ = new ::rlbot::api::Touch;
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.latest_touch)
  return latest_touch_;
}
inline ::rlbot::api::Touch* BallInfo::release_latest_touch() {
  clear_has_latest_touch();
  ::rlbot::api::Touch* temp = latest_touch_;
  latest_touch_ = NULL;
  return temp;
}
inline void BallInfo::set_allocated_latest_touch(::rlbot::api::Touch* latest_touch) {
  delete latest_touch_;
  latest_touch_ = latest_touch;
  if (latest_touch) {
    set_has_latest_touch();
  } else {
    clear_has_latest_touch();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.latest_touch)
}

// -------------------------------------------------------------------

// BoostInfo

// required .rlbot.api.Vector3 location = 1;
inline bool BoostInfo::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoostInfo::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoostInfo::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoostInfo::clear_location() {
  if (location_ != NULL) location_->::rlbot::api::Vector3::Clear();
  clear_has_location();
}
inline const ::rlbot::api::Vector3& BoostInfo::location() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BoostInfo.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::rlbot::api::Vector3* BoostInfo::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::rlbot::api::Vector3;
  // @@protoc_insertion_point(field_mutable:rlbot.api.BoostInfo.location)
  return location_;
}
inline ::rlbot::api::Vector3* BoostInfo::release_location() {
  clear_has_location();
  ::rlbot::api::Vector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline void BoostInfo::set_allocated_location(::rlbot::api::Vector3* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BoostInfo.location)
}

// required bool is_active = 2;
inline bool BoostInfo::has_is_active() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoostInfo::set_has_is_active() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoostInfo::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoostInfo::clear_is_active() {
  is_active_ = false;
  clear_has_is_active();
}
inline bool BoostInfo::is_active() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BoostInfo.is_active)
  return is_active_;
}
inline void BoostInfo::set_is_active(bool value) {
  set_has_is_active();
  is_active_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.BoostInfo.is_active)
}

// required float timer = 3;
inline bool BoostInfo::has_timer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoostInfo::set_has_timer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoostInfo::clear_has_timer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoostInfo::clear_timer() {
  timer_ = 0;
  clear_has_timer();
}
inline float BoostInfo::timer() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BoostInfo.timer)
  return timer_;
}
inline void BoostInfo::set_timer(float value) {
  set_has_timer();
  timer_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.BoostInfo.timer)
}

// -------------------------------------------------------------------

// GameInfo

// required float seconds_elapsed = 1;
inline bool GameInfo::has_seconds_elapsed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameInfo::set_has_seconds_elapsed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameInfo::clear_has_seconds_elapsed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameInfo::clear_seconds_elapsed() {
  seconds_elapsed_ = 0;
  clear_has_seconds_elapsed();
}
inline float GameInfo::seconds_elapsed() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.seconds_elapsed)
  return seconds_elapsed_;
}
inline void GameInfo::set_seconds_elapsed(float value) {
  set_has_seconds_elapsed();
  seconds_elapsed_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.seconds_elapsed)
}

// required float game_time_remaining = 2;
inline bool GameInfo::has_game_time_remaining() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameInfo::set_has_game_time_remaining() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameInfo::clear_has_game_time_remaining() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameInfo::clear_game_time_remaining() {
  game_time_remaining_ = 0;
  clear_has_game_time_remaining();
}
inline float GameInfo::game_time_remaining() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.game_time_remaining)
  return game_time_remaining_;
}
inline void GameInfo::set_game_time_remaining(float value) {
  set_has_game_time_remaining();
  game_time_remaining_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.game_time_remaining)
}

// required bool is_overtime = 3;
inline bool GameInfo::has_is_overtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameInfo::set_has_is_overtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameInfo::clear_has_is_overtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameInfo::clear_is_overtime() {
  is_overtime_ = false;
  clear_has_is_overtime();
}
inline bool GameInfo::is_overtime() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_overtime)
  return is_overtime_;
}
inline void GameInfo::set_is_overtime(bool value) {
  set_has_is_overtime();
  is_overtime_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_overtime)
}

// required bool is_unlimited_time = 4;
inline bool GameInfo::has_is_unlimited_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameInfo::set_has_is_unlimited_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameInfo::clear_has_is_unlimited_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameInfo::clear_is_unlimited_time() {
  is_unlimited_time_ = false;
  clear_has_is_unlimited_time();
}
inline bool GameInfo::is_unlimited_time() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_unlimited_time)
  return is_unlimited_time_;
}
inline void GameInfo::set_is_unlimited_time(bool value) {
  set_has_is_unlimited_time();
  is_unlimited_time_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_unlimited_time)
}

// required bool is_round_active = 5;
inline bool GameInfo::has_is_round_active() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameInfo::set_has_is_round_active() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameInfo::clear_has_is_round_active() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameInfo::clear_is_round_active() {
  is_round_active_ = false;
  clear_has_is_round_active();
}
inline bool GameInfo::is_round_active() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_round_active)
  return is_round_active_;
}
inline void GameInfo::set_is_round_active(bool value) {
  set_has_is_round_active();
  is_round_active_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_round_active)
}

// required bool is_kickoff_pause = 6;
inline bool GameInfo::has_is_kickoff_pause() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameInfo::set_has_is_kickoff_pause() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameInfo::clear_has_is_kickoff_pause() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameInfo::clear_is_kickoff_pause() {
  is_kickoff_pause_ = false;
  clear_has_is_kickoff_pause();
}
inline bool GameInfo::is_kickoff_pause() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_kickoff_pause)
  return is_kickoff_pause_;
}
inline void GameInfo::set_is_kickoff_pause(bool value) {
  set_has_is_kickoff_pause();
  is_kickoff_pause_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_kickoff_pause)
}

// required bool is_match_ended = 7;
inline bool GameInfo::has_is_match_ended() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameInfo::set_has_is_match_ended() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameInfo::clear_has_is_match_ended() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameInfo::clear_is_match_ended() {
  is_match_ended_ = false;
  clear_has_is_match_ended();
}
inline bool GameInfo::is_match_ended() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_match_ended)
  return is_match_ended_;
}
inline void GameInfo::set_is_match_ended(bool value) {
  set_has_is_match_ended();
  is_match_ended_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_match_ended)
}

// -------------------------------------------------------------------

// GameTickPacket

// repeated .rlbot.api.PlayerInfo players = 1;
inline int GameTickPacket::players_size() const {
  return players_.size();
}
inline void GameTickPacket::clear_players() {
  players_.Clear();
}
inline const ::rlbot::api::PlayerInfo& GameTickPacket::players(int index) const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.players)
  return players_.Get(index);
}
inline ::rlbot::api::PlayerInfo* GameTickPacket::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:rlbot.api.GameTickPacket.players)
  return players_.Mutable(index);
}
inline ::rlbot::api::PlayerInfo* GameTickPacket::add_players() {
  // @@protoc_insertion_point(field_add:rlbot.api.GameTickPacket.players)
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo >&
GameTickPacket::players() const {
  // @@protoc_insertion_point(field_list:rlbot.api.GameTickPacket.players)
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo >*
GameTickPacket::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:rlbot.api.GameTickPacket.players)
  return &players_;
}

// required int32 player_index = 2;
inline bool GameTickPacket::has_player_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameTickPacket::set_has_player_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameTickPacket::clear_has_player_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameTickPacket::clear_player_index() {
  player_index_ = 0;
  clear_has_player_index();
}
inline ::google::protobuf::int32 GameTickPacket::player_index() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.player_index)
  return player_index_;
}
inline void GameTickPacket::set_player_index(::google::protobuf::int32 value) {
  set_has_player_index();
  player_index_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameTickPacket.player_index)
}

// repeated .rlbot.api.BoostInfo boost_pads = 3;
inline int GameTickPacket::boost_pads_size() const {
  return boost_pads_.size();
}
inline void GameTickPacket::clear_boost_pads() {
  boost_pads_.Clear();
}
inline const ::rlbot::api::BoostInfo& GameTickPacket::boost_pads(int index) const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.boost_pads)
  return boost_pads_.Get(index);
}
inline ::rlbot::api::BoostInfo* GameTickPacket::mutable_boost_pads(int index) {
  // @@protoc_insertion_point(field_mutable:rlbot.api.GameTickPacket.boost_pads)
  return boost_pads_.Mutable(index);
}
inline ::rlbot::api::BoostInfo* GameTickPacket::add_boost_pads() {
  // @@protoc_insertion_point(field_add:rlbot.api.GameTickPacket.boost_pads)
  return boost_pads_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo >&
GameTickPacket::boost_pads() const {
  // @@protoc_insertion_point(field_list:rlbot.api.GameTickPacket.boost_pads)
  return boost_pads_;
}
inline ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo >*
GameTickPacket::mutable_boost_pads() {
  // @@protoc_insertion_point(field_mutable_list:rlbot.api.GameTickPacket.boost_pads)
  return &boost_pads_;
}

// required .rlbot.api.BallInfo ball = 4;
inline bool GameTickPacket::has_ball() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameTickPacket::set_has_ball() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameTickPacket::clear_has_ball() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameTickPacket::clear_ball() {
  if (ball_ != NULL) ball_->::rlbot::api::BallInfo::Clear();
  clear_has_ball();
}
inline const ::rlbot::api::BallInfo& GameTickPacket::ball() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.ball)
  return ball_ != NULL ? *ball_ : *default_instance_->ball_;
}
inline ::rlbot::api::BallInfo* GameTickPacket::mutable_ball() {
  set_has_ball();
  if (ball_ == NULL) ball_ = new ::rlbot::api::BallInfo;
  // @@protoc_insertion_point(field_mutable:rlbot.api.GameTickPacket.ball)
  return ball_;
}
inline ::rlbot::api::BallInfo* GameTickPacket::release_ball() {
  clear_has_ball();
  ::rlbot::api::BallInfo* temp = ball_;
  ball_ = NULL;
  return temp;
}
inline void GameTickPacket::set_allocated_ball(::rlbot::api::BallInfo* ball) {
  delete ball_;
  ball_ = ball;
  if (ball) {
    set_has_ball();
  } else {
    clear_has_ball();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.GameTickPacket.ball)
}

// required .rlbot.api.GameInfo game_info = 5;
inline bool GameTickPacket::has_game_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameTickPacket::set_has_game_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameTickPacket::clear_has_game_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameTickPacket::clear_game_info() {
  if (game_info_ != NULL) game_info_->::rlbot::api::GameInfo::Clear();
  clear_has_game_info();
}
inline const ::rlbot::api::GameInfo& GameTickPacket::game_info() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.game_info)
  return game_info_ != NULL ? *game_info_ : *default_instance_->game_info_;
}
inline ::rlbot::api::GameInfo* GameTickPacket::mutable_game_info() {
  set_has_game_info();
  if (game_info_ == NULL) game_info_ = new ::rlbot::api::GameInfo;
  // @@protoc_insertion_point(field_mutable:rlbot.api.GameTickPacket.game_info)
  return game_info_;
}
inline ::rlbot::api::GameInfo* GameTickPacket::release_game_info() {
  clear_has_game_info();
  ::rlbot::api::GameInfo* temp = game_info_;
  game_info_ = NULL;
  return temp;
}
inline void GameTickPacket::set_allocated_game_info(::rlbot::api::GameInfo* game_info) {
  delete game_info_;
  game_info_ = game_info;
  if (game_info) {
    set_has_game_info();
  } else {
    clear_has_game_info();
  }
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.GameTickPacket.game_info)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace rlbot

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_game_5fdata_2eproto__INCLUDED
