// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: game_data.capnp

#ifndef CAPNP_INCLUDED_cb4ac4a4827ed032_
#define CAPNP_INCLUDED_cb4ac4a4827ed032_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 6001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(f90c0330aeedd655);
CAPNP_DECLARE_SCHEMA(a258536749d6c031);
CAPNP_DECLARE_SCHEMA(e88c1431291a54d3);
CAPNP_DECLARE_SCHEMA(c36d3a2cc31ef37e);
CAPNP_DECLARE_SCHEMA(dedbc01fee1d9c32);
CAPNP_DECLARE_SCHEMA(f4bcd11fd8f3e686);
CAPNP_DECLARE_SCHEMA(880c42accae33646);
CAPNP_DECLARE_SCHEMA(af834567271158ed);
CAPNP_DECLARE_SCHEMA(fc1ef69b4eec4872);
CAPNP_DECLARE_SCHEMA(d723ec892baf9236);
CAPNP_DECLARE_SCHEMA(a1f85a5315c0211b);
CAPNP_DECLARE_SCHEMA(a528c02d914576d5);
CAPNP_DECLARE_SCHEMA(ef8a7b94871a4bca);
CAPNP_DECLARE_SCHEMA(8681d7a9a355f85f);
CAPNP_DECLARE_SCHEMA(9a27d153e5161538);
CAPNP_DECLARE_SCHEMA(c643998fb893b409);
CAPNP_DECLARE_SCHEMA(be719710489841f3);
CAPNP_DECLARE_SCHEMA(83670cc19d3b6261);
CAPNP_DECLARE_SCHEMA(bca5e2a1d8a79f53);
CAPNP_DECLARE_SCHEMA(c3d84eeea4eebda3);
CAPNP_DECLARE_SCHEMA(e929bf56692c672d);
CAPNP_DECLARE_SCHEMA(e4f9983acd0b4e69);
CAPNP_DECLARE_SCHEMA(86cdaa3f692b8584);

}  // namespace schemas
}  // namespace capnp

namespace rlbot {

struct ControllerState {
  ControllerState() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f90c0330aeedd655, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PlayerInput {
  PlayerInput() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a258536749d6c031, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector3 {
  Vector3() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e88c1431291a54d3, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Rotator {
  Rotator() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c36d3a2cc31ef37e, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Touch {
  Touch() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dedbc01fee1d9c32, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ScoreInfo {
  ScoreInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f4bcd11fd8f3e686, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PlayerInfo {
  PlayerInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(880c42accae33646, 2, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BallInfo {
  BallInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(af834567271158ed, 0, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BoostInfo {
  BoostInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fc1ef69b4eec4872, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GameInfo {
  GameInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d723ec892baf9236, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GameTickPacket {
  GameTickPacket() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a1f85a5315c0211b, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector3Partial {
  Vector3Partial() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct X;
  struct Y;
  struct Z;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a528c02d914576d5, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector3Partial::X {
  X() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNSET,
    VALUE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ef8a7b94871a4bca, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector3Partial::Y {
  Y() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNSET,
    VALUE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8681d7a9a355f85f, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector3Partial::Z {
  Z() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNSET,
    VALUE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9a27d153e5161538, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RotatorPartial {
  RotatorPartial() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Pitch;
  struct Yaw;
  struct Roll;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c643998fb893b409, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RotatorPartial::Pitch {
  Pitch() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNSET,
    VALUE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(be719710489841f3, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RotatorPartial::Yaw {
  Yaw() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNSET,
    VALUE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(83670cc19d3b6261, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RotatorPartial::Roll {
  Roll() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNSET,
    VALUE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bca5e2a1d8a79f53, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DesiredPhysics {
  DesiredPhysics() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c3d84eeea4eebda3, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DesiredBallState {
  DesiredBallState() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e929bf56692c672d, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DesiredCarState {
  DesiredCarState() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e4f9983acd0b4e69, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DesiredGameState {
  DesiredGameState() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(86cdaa3f692b8584, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class ControllerState::Reader {
public:
  typedef ControllerState Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getThrottle() const;

  inline float getSteer() const;

  inline float getPitch() const;

  inline float getYaw() const;

  inline float getRoll() const;

  inline bool getJump() const;

  inline bool getBoost() const;

  inline bool getHandbrake() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ControllerState::Builder {
public:
  typedef ControllerState Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getThrottle();
  inline void setThrottle(float value);

  inline float getSteer();
  inline void setSteer(float value);

  inline float getPitch();
  inline void setPitch(float value);

  inline float getYaw();
  inline void setYaw(float value);

  inline float getRoll();
  inline void setRoll(float value);

  inline bool getJump();
  inline void setJump(bool value);

  inline bool getBoost();
  inline void setBoost(bool value);

  inline bool getHandbrake();
  inline void setHandbrake(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ControllerState::Pipeline {
public:
  typedef ControllerState Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PlayerInput::Reader {
public:
  typedef PlayerInput Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getPlayerIndex() const;

  inline bool hasControllerState() const;
  inline  ::rlbot::ControllerState::Reader getControllerState() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PlayerInput::Builder {
public:
  typedef PlayerInput Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getPlayerIndex();
  inline void setPlayerIndex( ::int32_t value);

  inline bool hasControllerState();
  inline  ::rlbot::ControllerState::Builder getControllerState();
  inline void setControllerState( ::rlbot::ControllerState::Reader value);
  inline  ::rlbot::ControllerState::Builder initControllerState();
  inline void adoptControllerState(::capnp::Orphan< ::rlbot::ControllerState>&& value);
  inline ::capnp::Orphan< ::rlbot::ControllerState> disownControllerState();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PlayerInput::Pipeline {
public:
  typedef PlayerInput Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::rlbot::ControllerState::Pipeline getControllerState();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector3::Reader {
public:
  typedef Vector3 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

  inline float getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector3::Builder {
public:
  typedef Vector3 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline float getZ();
  inline void setZ(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector3::Pipeline {
public:
  typedef Vector3 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Rotator::Reader {
public:
  typedef Rotator Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getPitch() const;

  inline float getYaw() const;

  inline float getRoll() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Rotator::Builder {
public:
  typedef Rotator Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getPitch();
  inline void setPitch(float value);

  inline float getYaw();
  inline void setYaw(float value);

  inline float getRoll();
  inline void setRoll(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Rotator::Pipeline {
public:
  typedef Rotator Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Touch::Reader {
public:
  typedef Touch Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPlayerName() const;
  inline  ::capnp::Text::Reader getPlayerName() const;

  inline float getGameSeconds() const;

  inline bool hasLocation() const;
  inline  ::rlbot::Vector3::Reader getLocation() const;

  inline bool hasNormal() const;
  inline  ::rlbot::Vector3::Reader getNormal() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Touch::Builder {
public:
  typedef Touch Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPlayerName();
  inline  ::capnp::Text::Builder getPlayerName();
  inline void setPlayerName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPlayerName(unsigned int size);
  inline void adoptPlayerName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPlayerName();

  inline float getGameSeconds();
  inline void setGameSeconds(float value);

  inline bool hasLocation();
  inline  ::rlbot::Vector3::Builder getLocation();
  inline void setLocation( ::rlbot::Vector3::Reader value);
  inline  ::rlbot::Vector3::Builder initLocation();
  inline void adoptLocation(::capnp::Orphan< ::rlbot::Vector3>&& value);
  inline ::capnp::Orphan< ::rlbot::Vector3> disownLocation();

  inline bool hasNormal();
  inline  ::rlbot::Vector3::Builder getNormal();
  inline void setNormal( ::rlbot::Vector3::Reader value);
  inline  ::rlbot::Vector3::Builder initNormal();
  inline void adoptNormal(::capnp::Orphan< ::rlbot::Vector3>&& value);
  inline ::capnp::Orphan< ::rlbot::Vector3> disownNormal();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Touch::Pipeline {
public:
  typedef Touch Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::rlbot::Vector3::Pipeline getLocation();
  inline  ::rlbot::Vector3::Pipeline getNormal();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ScoreInfo::Reader {
public:
  typedef ScoreInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getScore() const;

  inline  ::int32_t getGoals() const;

  inline  ::int32_t getOwnGoals() const;

  inline  ::int32_t getAssists() const;

  inline  ::int32_t getSaves() const;

  inline  ::int32_t getShots() const;

  inline  ::int32_t getDemolitions() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ScoreInfo::Builder {
public:
  typedef ScoreInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getScore();
  inline void setScore( ::int32_t value);

  inline  ::int32_t getGoals();
  inline void setGoals( ::int32_t value);

  inline  ::int32_t getOwnGoals();
  inline void setOwnGoals( ::int32_t value);

  inline  ::int32_t getAssists();
  inline void setAssists( ::int32_t value);

  inline  ::int32_t getSaves();
  inline void setSaves( ::int32_t value);

  inline  ::int32_t getShots();
  inline void setShots( ::int32_t value);

  inline  ::int32_t getDemolitions();
  inline void setDemolitions( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ScoreInfo::Pipeline {
public:
  typedef ScoreInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PlayerInfo::Reader {
public:
  typedef PlayerInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLocation() const;
  inline  ::rlbot::Vector3::Reader getLocation() const;

  inline bool hasRotation() const;
  inline  ::rlbot::Rotator::Reader getRotation() const;

  inline bool hasVelocity() const;
  inline  ::rlbot::Vector3::Reader getVelocity() const;

  inline bool hasAngularVelocity() const;
  inline  ::rlbot::Vector3::Reader getAngularVelocity() const;

  inline bool hasScoreInfo() const;
  inline  ::rlbot::ScoreInfo::Reader getScoreInfo() const;

  inline bool getIsDemolished() const;

  inline bool getIsMidair() const;

  inline bool getIsSupersonic() const;

  inline bool getIsBot() const;

  inline bool getJumped() const;

  inline bool getDoubleJumped() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::int32_t getTeam() const;

  inline  ::int32_t getBoost() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PlayerInfo::Builder {
public:
  typedef PlayerInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLocation();
  inline  ::rlbot::Vector3::Builder getLocation();
  inline void setLocation( ::rlbot::Vector3::Reader value);
  inline  ::rlbot::Vector3::Builder initLocation();
  inline void adoptLocation(::capnp::Orphan< ::rlbot::Vector3>&& value);
  inline ::capnp::Orphan< ::rlbot::Vector3> disownLocation();

  inline bool hasRotation();
  inline  ::rlbot::Rotator::Builder getRotation();
  inline void setRotation( ::rlbot::Rotator::Reader value);
  inline  ::rlbot::Rotator::Builder initRotation();
  inline void adoptRotation(::capnp::Orphan< ::rlbot::Rotator>&& value);
  inline ::capnp::Orphan< ::rlbot::Rotator> disownRotation();

  inline bool hasVelocity();
  inline  ::rlbot::Vector3::Builder getVelocity();
  inline void setVelocity( ::rlbot::Vector3::Reader value);
  inline  ::rlbot::Vector3::Builder initVelocity();
  inline void adoptVelocity(::capnp::Orphan< ::rlbot::Vector3>&& value);
  inline ::capnp::Orphan< ::rlbot::Vector3> disownVelocity();

  inline bool hasAngularVelocity();
  inline  ::rlbot::Vector3::Builder getAngularVelocity();
  inline void setAngularVelocity( ::rlbot::Vector3::Reader value);
  inline  ::rlbot::Vector3::Builder initAngularVelocity();
  inline void adoptAngularVelocity(::capnp::Orphan< ::rlbot::Vector3>&& value);
  inline ::capnp::Orphan< ::rlbot::Vector3> disownAngularVelocity();

  inline bool hasScoreInfo();
  inline  ::rlbot::ScoreInfo::Builder getScoreInfo();
  inline void setScoreInfo( ::rlbot::ScoreInfo::Reader value);
  inline  ::rlbot::ScoreInfo::Builder initScoreInfo();
  inline void adoptScoreInfo(::capnp::Orphan< ::rlbot::ScoreInfo>&& value);
  inline ::capnp::Orphan< ::rlbot::ScoreInfo> disownScoreInfo();

  inline bool getIsDemolished();
  inline void setIsDemolished(bool value);

  inline bool getIsMidair();
  inline void setIsMidair(bool value);

  inline bool getIsSupersonic();
  inline void setIsSupersonic(bool value);

  inline bool getIsBot();
  inline void setIsBot(bool value);

  inline bool getJumped();
  inline void setJumped(bool value);

  inline bool getDoubleJumped();
  inline void setDoubleJumped(bool value);

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::int32_t getTeam();
  inline void setTeam( ::int32_t value);

  inline  ::int32_t getBoost();
  inline void setBoost( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PlayerInfo::Pipeline {
public:
  typedef PlayerInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::rlbot::Vector3::Pipeline getLocation();
  inline  ::rlbot::Rotator::Pipeline getRotation();
  inline  ::rlbot::Vector3::Pipeline getVelocity();
  inline  ::rlbot::Vector3::Pipeline getAngularVelocity();
  inline  ::rlbot::ScoreInfo::Pipeline getScoreInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BallInfo::Reader {
public:
  typedef BallInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLocation() const;
  inline  ::rlbot::Vector3::Reader getLocation() const;

  inline bool hasRotation() const;
  inline  ::rlbot::Rotator::Reader getRotation() const;

  inline bool hasVelocity() const;
  inline  ::rlbot::Vector3::Reader getVelocity() const;

  inline bool hasAngularVelocity() const;
  inline  ::rlbot::Vector3::Reader getAngularVelocity() const;

  inline bool hasLatestTouch() const;
  inline  ::rlbot::Touch::Reader getLatestTouch() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BallInfo::Builder {
public:
  typedef BallInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLocation();
  inline  ::rlbot::Vector3::Builder getLocation();
  inline void setLocation( ::rlbot::Vector3::Reader value);
  inline  ::rlbot::Vector3::Builder initLocation();
  inline void adoptLocation(::capnp::Orphan< ::rlbot::Vector3>&& value);
  inline ::capnp::Orphan< ::rlbot::Vector3> disownLocation();

  inline bool hasRotation();
  inline  ::rlbot::Rotator::Builder getRotation();
  inline void setRotation( ::rlbot::Rotator::Reader value);
  inline  ::rlbot::Rotator::Builder initRotation();
  inline void adoptRotation(::capnp::Orphan< ::rlbot::Rotator>&& value);
  inline ::capnp::Orphan< ::rlbot::Rotator> disownRotation();

  inline bool hasVelocity();
  inline  ::rlbot::Vector3::Builder getVelocity();
  inline void setVelocity( ::rlbot::Vector3::Reader value);
  inline  ::rlbot::Vector3::Builder initVelocity();
  inline void adoptVelocity(::capnp::Orphan< ::rlbot::Vector3>&& value);
  inline ::capnp::Orphan< ::rlbot::Vector3> disownVelocity();

  inline bool hasAngularVelocity();
  inline  ::rlbot::Vector3::Builder getAngularVelocity();
  inline void setAngularVelocity( ::rlbot::Vector3::Reader value);
  inline  ::rlbot::Vector3::Builder initAngularVelocity();
  inline void adoptAngularVelocity(::capnp::Orphan< ::rlbot::Vector3>&& value);
  inline ::capnp::Orphan< ::rlbot::Vector3> disownAngularVelocity();

  inline bool hasLatestTouch();
  inline  ::rlbot::Touch::Builder getLatestTouch();
  inline void setLatestTouch( ::rlbot::Touch::Reader value);
  inline  ::rlbot::Touch::Builder initLatestTouch();
  inline void adoptLatestTouch(::capnp::Orphan< ::rlbot::Touch>&& value);
  inline ::capnp::Orphan< ::rlbot::Touch> disownLatestTouch();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BallInfo::Pipeline {
public:
  typedef BallInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::rlbot::Vector3::Pipeline getLocation();
  inline  ::rlbot::Rotator::Pipeline getRotation();
  inline  ::rlbot::Vector3::Pipeline getVelocity();
  inline  ::rlbot::Vector3::Pipeline getAngularVelocity();
  inline  ::rlbot::Touch::Pipeline getLatestTouch();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BoostInfo::Reader {
public:
  typedef BoostInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLocation() const;
  inline  ::rlbot::Vector3::Reader getLocation() const;

  inline bool getIsActive() const;

  inline float getTimer() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BoostInfo::Builder {
public:
  typedef BoostInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLocation();
  inline  ::rlbot::Vector3::Builder getLocation();
  inline void setLocation( ::rlbot::Vector3::Reader value);
  inline  ::rlbot::Vector3::Builder initLocation();
  inline void adoptLocation(::capnp::Orphan< ::rlbot::Vector3>&& value);
  inline ::capnp::Orphan< ::rlbot::Vector3> disownLocation();

  inline bool getIsActive();
  inline void setIsActive(bool value);

  inline float getTimer();
  inline void setTimer(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BoostInfo::Pipeline {
public:
  typedef BoostInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::rlbot::Vector3::Pipeline getLocation();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GameInfo::Reader {
public:
  typedef GameInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getSecondsElapsed() const;

  inline float getGameTimeRemaining() const;

  inline bool getIsOvertime() const;

  inline bool getIsUnlimitedTime() const;

  inline bool getIsRoundActive() const;

  inline bool getIsKickoffPause() const;

  inline bool getIsMatchEnded() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GameInfo::Builder {
public:
  typedef GameInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getSecondsElapsed();
  inline void setSecondsElapsed(float value);

  inline float getGameTimeRemaining();
  inline void setGameTimeRemaining(float value);

  inline bool getIsOvertime();
  inline void setIsOvertime(bool value);

  inline bool getIsUnlimitedTime();
  inline void setIsUnlimitedTime(bool value);

  inline bool getIsRoundActive();
  inline void setIsRoundActive(bool value);

  inline bool getIsKickoffPause();
  inline void setIsKickoffPause(bool value);

  inline bool getIsMatchEnded();
  inline void setIsMatchEnded(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GameInfo::Pipeline {
public:
  typedef GameInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GameTickPacket::Reader {
public:
  typedef GameTickPacket Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPlayers() const;
  inline  ::capnp::List< ::rlbot::PlayerInfo>::Reader getPlayers() const;

  inline  ::int32_t getPlayerIndex() const;

  inline bool hasBoostPads() const;
  inline  ::capnp::List< ::rlbot::BoostInfo>::Reader getBoostPads() const;

  inline bool hasBall() const;
  inline  ::rlbot::BallInfo::Reader getBall() const;

  inline bool hasGameInfo() const;
  inline  ::rlbot::GameInfo::Reader getGameInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GameTickPacket::Builder {
public:
  typedef GameTickPacket Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPlayers();
  inline  ::capnp::List< ::rlbot::PlayerInfo>::Builder getPlayers();
  inline void setPlayers( ::capnp::List< ::rlbot::PlayerInfo>::Reader value);
  inline  ::capnp::List< ::rlbot::PlayerInfo>::Builder initPlayers(unsigned int size);
  inline void adoptPlayers(::capnp::Orphan< ::capnp::List< ::rlbot::PlayerInfo>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::rlbot::PlayerInfo>> disownPlayers();

  inline  ::int32_t getPlayerIndex();
  inline void setPlayerIndex( ::int32_t value);

  inline bool hasBoostPads();
  inline  ::capnp::List< ::rlbot::BoostInfo>::Builder getBoostPads();
  inline void setBoostPads( ::capnp::List< ::rlbot::BoostInfo>::Reader value);
  inline  ::capnp::List< ::rlbot::BoostInfo>::Builder initBoostPads(unsigned int size);
  inline void adoptBoostPads(::capnp::Orphan< ::capnp::List< ::rlbot::BoostInfo>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::rlbot::BoostInfo>> disownBoostPads();

  inline bool hasBall();
  inline  ::rlbot::BallInfo::Builder getBall();
  inline void setBall( ::rlbot::BallInfo::Reader value);
  inline  ::rlbot::BallInfo::Builder initBall();
  inline void adoptBall(::capnp::Orphan< ::rlbot::BallInfo>&& value);
  inline ::capnp::Orphan< ::rlbot::BallInfo> disownBall();

  inline bool hasGameInfo();
  inline  ::rlbot::GameInfo::Builder getGameInfo();
  inline void setGameInfo( ::rlbot::GameInfo::Reader value);
  inline  ::rlbot::GameInfo::Builder initGameInfo();
  inline void adoptGameInfo(::capnp::Orphan< ::rlbot::GameInfo>&& value);
  inline ::capnp::Orphan< ::rlbot::GameInfo> disownGameInfo();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GameTickPacket::Pipeline {
public:
  typedef GameTickPacket Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::rlbot::BallInfo::Pipeline getBall();
  inline  ::rlbot::GameInfo::Pipeline getGameInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector3Partial::Reader {
public:
  typedef Vector3Partial Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline typename X::Reader getX() const;

  inline typename Y::Reader getY() const;

  inline typename Z::Reader getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector3Partial::Builder {
public:
  typedef Vector3Partial Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline typename X::Builder getX();
  inline typename X::Builder initX();

  inline typename Y::Builder getY();
  inline typename Y::Builder initY();

  inline typename Z::Builder getZ();
  inline typename Z::Builder initZ();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector3Partial::Pipeline {
public:
  typedef Vector3Partial Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename X::Pipeline getX();
  inline typename Y::Pipeline getY();
  inline typename Z::Pipeline getZ();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector3Partial::X::Reader {
public:
  typedef X Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnset() const;
  inline  ::capnp::Void getUnset() const;

  inline bool isValue() const;
  inline float getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector3Partial::X::Builder {
public:
  typedef X Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnset();
  inline  ::capnp::Void getUnset();
  inline void setUnset( ::capnp::Void value = ::capnp::VOID);

  inline bool isValue();
  inline float getValue();
  inline void setValue(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector3Partial::X::Pipeline {
public:
  typedef X Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector3Partial::Y::Reader {
public:
  typedef Y Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnset() const;
  inline  ::capnp::Void getUnset() const;

  inline bool isValue() const;
  inline float getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector3Partial::Y::Builder {
public:
  typedef Y Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnset();
  inline  ::capnp::Void getUnset();
  inline void setUnset( ::capnp::Void value = ::capnp::VOID);

  inline bool isValue();
  inline float getValue();
  inline void setValue(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector3Partial::Y::Pipeline {
public:
  typedef Y Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector3Partial::Z::Reader {
public:
  typedef Z Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnset() const;
  inline  ::capnp::Void getUnset() const;

  inline bool isValue() const;
  inline float getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector3Partial::Z::Builder {
public:
  typedef Z Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnset();
  inline  ::capnp::Void getUnset();
  inline void setUnset( ::capnp::Void value = ::capnp::VOID);

  inline bool isValue();
  inline float getValue();
  inline void setValue(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector3Partial::Z::Pipeline {
public:
  typedef Z Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RotatorPartial::Reader {
public:
  typedef RotatorPartial Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline typename Pitch::Reader getPitch() const;

  inline typename Yaw::Reader getYaw() const;

  inline typename Roll::Reader getRoll() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RotatorPartial::Builder {
public:
  typedef RotatorPartial Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline typename Pitch::Builder getPitch();
  inline typename Pitch::Builder initPitch();

  inline typename Yaw::Builder getYaw();
  inline typename Yaw::Builder initYaw();

  inline typename Roll::Builder getRoll();
  inline typename Roll::Builder initRoll();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RotatorPartial::Pipeline {
public:
  typedef RotatorPartial Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Pitch::Pipeline getPitch();
  inline typename Yaw::Pipeline getYaw();
  inline typename Roll::Pipeline getRoll();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RotatorPartial::Pitch::Reader {
public:
  typedef Pitch Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnset() const;
  inline  ::capnp::Void getUnset() const;

  inline bool isValue() const;
  inline float getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RotatorPartial::Pitch::Builder {
public:
  typedef Pitch Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnset();
  inline  ::capnp::Void getUnset();
  inline void setUnset( ::capnp::Void value = ::capnp::VOID);

  inline bool isValue();
  inline float getValue();
  inline void setValue(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RotatorPartial::Pitch::Pipeline {
public:
  typedef Pitch Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RotatorPartial::Yaw::Reader {
public:
  typedef Yaw Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnset() const;
  inline  ::capnp::Void getUnset() const;

  inline bool isValue() const;
  inline float getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RotatorPartial::Yaw::Builder {
public:
  typedef Yaw Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnset();
  inline  ::capnp::Void getUnset();
  inline void setUnset( ::capnp::Void value = ::capnp::VOID);

  inline bool isValue();
  inline float getValue();
  inline void setValue(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RotatorPartial::Yaw::Pipeline {
public:
  typedef Yaw Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RotatorPartial::Roll::Reader {
public:
  typedef Roll Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnset() const;
  inline  ::capnp::Void getUnset() const;

  inline bool isValue() const;
  inline float getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RotatorPartial::Roll::Builder {
public:
  typedef Roll Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnset();
  inline  ::capnp::Void getUnset();
  inline void setUnset( ::capnp::Void value = ::capnp::VOID);

  inline bool isValue();
  inline float getValue();
  inline void setValue(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RotatorPartial::Roll::Pipeline {
public:
  typedef Roll Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DesiredPhysics::Reader {
public:
  typedef DesiredPhysics Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLocation() const;
  inline  ::rlbot::Vector3Partial::Reader getLocation() const;

  inline bool hasRotation() const;
  inline  ::rlbot::RotatorPartial::Reader getRotation() const;

  inline bool hasVelocity() const;
  inline  ::rlbot::Vector3Partial::Reader getVelocity() const;

  inline bool hasAngularVelocity() const;
  inline  ::rlbot::Vector3Partial::Reader getAngularVelocity() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DesiredPhysics::Builder {
public:
  typedef DesiredPhysics Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLocation();
  inline  ::rlbot::Vector3Partial::Builder getLocation();
  inline void setLocation( ::rlbot::Vector3Partial::Reader value);
  inline  ::rlbot::Vector3Partial::Builder initLocation();
  inline void adoptLocation(::capnp::Orphan< ::rlbot::Vector3Partial>&& value);
  inline ::capnp::Orphan< ::rlbot::Vector3Partial> disownLocation();

  inline bool hasRotation();
  inline  ::rlbot::RotatorPartial::Builder getRotation();
  inline void setRotation( ::rlbot::RotatorPartial::Reader value);
  inline  ::rlbot::RotatorPartial::Builder initRotation();
  inline void adoptRotation(::capnp::Orphan< ::rlbot::RotatorPartial>&& value);
  inline ::capnp::Orphan< ::rlbot::RotatorPartial> disownRotation();

  inline bool hasVelocity();
  inline  ::rlbot::Vector3Partial::Builder getVelocity();
  inline void setVelocity( ::rlbot::Vector3Partial::Reader value);
  inline  ::rlbot::Vector3Partial::Builder initVelocity();
  inline void adoptVelocity(::capnp::Orphan< ::rlbot::Vector3Partial>&& value);
  inline ::capnp::Orphan< ::rlbot::Vector3Partial> disownVelocity();

  inline bool hasAngularVelocity();
  inline  ::rlbot::Vector3Partial::Builder getAngularVelocity();
  inline void setAngularVelocity( ::rlbot::Vector3Partial::Reader value);
  inline  ::rlbot::Vector3Partial::Builder initAngularVelocity();
  inline void adoptAngularVelocity(::capnp::Orphan< ::rlbot::Vector3Partial>&& value);
  inline ::capnp::Orphan< ::rlbot::Vector3Partial> disownAngularVelocity();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DesiredPhysics::Pipeline {
public:
  typedef DesiredPhysics Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::rlbot::Vector3Partial::Pipeline getLocation();
  inline  ::rlbot::RotatorPartial::Pipeline getRotation();
  inline  ::rlbot::Vector3Partial::Pipeline getVelocity();
  inline  ::rlbot::Vector3Partial::Pipeline getAngularVelocity();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DesiredBallState::Reader {
public:
  typedef DesiredBallState Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPhysics() const;
  inline  ::rlbot::DesiredPhysics::Reader getPhysics() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DesiredBallState::Builder {
public:
  typedef DesiredBallState Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPhysics();
  inline  ::rlbot::DesiredPhysics::Builder getPhysics();
  inline void setPhysics( ::rlbot::DesiredPhysics::Reader value);
  inline  ::rlbot::DesiredPhysics::Builder initPhysics();
  inline void adoptPhysics(::capnp::Orphan< ::rlbot::DesiredPhysics>&& value);
  inline ::capnp::Orphan< ::rlbot::DesiredPhysics> disownPhysics();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DesiredBallState::Pipeline {
public:
  typedef DesiredBallState Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::rlbot::DesiredPhysics::Pipeline getPhysics();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DesiredCarState::Reader {
public:
  typedef DesiredCarState Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPhysics() const;
  inline  ::rlbot::DesiredPhysics::Reader getPhysics() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DesiredCarState::Builder {
public:
  typedef DesiredCarState Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPhysics();
  inline  ::rlbot::DesiredPhysics::Builder getPhysics();
  inline void setPhysics( ::rlbot::DesiredPhysics::Reader value);
  inline  ::rlbot::DesiredPhysics::Builder initPhysics();
  inline void adoptPhysics(::capnp::Orphan< ::rlbot::DesiredPhysics>&& value);
  inline ::capnp::Orphan< ::rlbot::DesiredPhysics> disownPhysics();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DesiredCarState::Pipeline {
public:
  typedef DesiredCarState Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::rlbot::DesiredPhysics::Pipeline getPhysics();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DesiredGameState::Reader {
public:
  typedef DesiredGameState Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBallState() const;
  inline  ::rlbot::DesiredBallState::Reader getBallState() const;

  inline bool hasCarSates() const;
  inline  ::capnp::List< ::rlbot::DesiredCarState>::Reader getCarSates() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DesiredGameState::Builder {
public:
  typedef DesiredGameState Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBallState();
  inline  ::rlbot::DesiredBallState::Builder getBallState();
  inline void setBallState( ::rlbot::DesiredBallState::Reader value);
  inline  ::rlbot::DesiredBallState::Builder initBallState();
  inline void adoptBallState(::capnp::Orphan< ::rlbot::DesiredBallState>&& value);
  inline ::capnp::Orphan< ::rlbot::DesiredBallState> disownBallState();

  inline bool hasCarSates();
  inline  ::capnp::List< ::rlbot::DesiredCarState>::Builder getCarSates();
  inline void setCarSates( ::capnp::List< ::rlbot::DesiredCarState>::Reader value);
  inline  ::capnp::List< ::rlbot::DesiredCarState>::Builder initCarSates(unsigned int size);
  inline void adoptCarSates(::capnp::Orphan< ::capnp::List< ::rlbot::DesiredCarState>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::rlbot::DesiredCarState>> disownCarSates();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DesiredGameState::Pipeline {
public:
  typedef DesiredGameState Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::rlbot::DesiredBallState::Pipeline getBallState();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline float ControllerState::Reader::getThrottle() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float ControllerState::Builder::getThrottle() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ControllerState::Builder::setThrottle(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float ControllerState::Reader::getSteer() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float ControllerState::Builder::getSteer() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ControllerState::Builder::setSteer(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float ControllerState::Reader::getPitch() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float ControllerState::Builder::getPitch() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void ControllerState::Builder::setPitch(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float ControllerState::Reader::getYaw() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float ControllerState::Builder::getYaw() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void ControllerState::Builder::setYaw(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float ControllerState::Reader::getRoll() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float ControllerState::Builder::getRoll() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void ControllerState::Builder::setRoll(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool ControllerState::Reader::getJump() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<160>() * ::capnp::ELEMENTS);
}

inline bool ControllerState::Builder::getJump() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<160>() * ::capnp::ELEMENTS);
}
inline void ControllerState::Builder::setJump(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<160>() * ::capnp::ELEMENTS, value);
}

inline bool ControllerState::Reader::getBoost() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<161>() * ::capnp::ELEMENTS);
}

inline bool ControllerState::Builder::getBoost() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<161>() * ::capnp::ELEMENTS);
}
inline void ControllerState::Builder::setBoost(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<161>() * ::capnp::ELEMENTS, value);
}

inline bool ControllerState::Reader::getHandbrake() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<162>() * ::capnp::ELEMENTS);
}

inline bool ControllerState::Builder::getHandbrake() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<162>() * ::capnp::ELEMENTS);
}
inline void ControllerState::Builder::setHandbrake(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<162>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t PlayerInput::Reader::getPlayerIndex() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t PlayerInput::Builder::getPlayerIndex() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PlayerInput::Builder::setPlayerIndex( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool PlayerInput::Reader::hasControllerState() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PlayerInput::Builder::hasControllerState() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::ControllerState::Reader PlayerInput::Reader::getControllerState() const {
  return ::capnp::_::PointerHelpers< ::rlbot::ControllerState>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::rlbot::ControllerState::Builder PlayerInput::Builder::getControllerState() {
  return ::capnp::_::PointerHelpers< ::rlbot::ControllerState>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::ControllerState::Pipeline PlayerInput::Pipeline::getControllerState() {
  return  ::rlbot::ControllerState::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PlayerInput::Builder::setControllerState( ::rlbot::ControllerState::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::ControllerState>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::ControllerState::Builder PlayerInput::Builder::initControllerState() {
  return ::capnp::_::PointerHelpers< ::rlbot::ControllerState>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PlayerInput::Builder::adoptControllerState(
    ::capnp::Orphan< ::rlbot::ControllerState>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::ControllerState>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::ControllerState> PlayerInput::Builder::disownControllerState() {
  return ::capnp::_::PointerHelpers< ::rlbot::ControllerState>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float Vector3::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Vector3::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector3::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Vector3::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Vector3::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Vector3::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Vector3::Reader::getZ() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Vector3::Builder::getZ() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Vector3::Builder::setZ(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float Rotator::Reader::getPitch() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Rotator::Builder::getPitch() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Rotator::Builder::setPitch(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Rotator::Reader::getYaw() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Rotator::Builder::getYaw() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Rotator::Builder::setYaw(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Rotator::Reader::getRoll() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Rotator::Builder::getRoll() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Rotator::Builder::setRoll(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Touch::Reader::hasPlayerName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Touch::Builder::hasPlayerName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Touch::Reader::getPlayerName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Touch::Builder::getPlayerName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Touch::Builder::setPlayerName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Touch::Builder::initPlayerName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Touch::Builder::adoptPlayerName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Touch::Builder::disownPlayerName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float Touch::Reader::getGameSeconds() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Touch::Builder::getGameSeconds() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Touch::Builder::setGameSeconds(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Touch::Reader::hasLocation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Touch::Builder::hasLocation() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Vector3::Reader Touch::Reader::getLocation() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::rlbot::Vector3::Builder Touch::Builder::getLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Vector3::Pipeline Touch::Pipeline::getLocation() {
  return  ::rlbot::Vector3::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Touch::Builder::setLocation( ::rlbot::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Vector3::Builder Touch::Builder::initLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Touch::Builder::adoptLocation(
    ::capnp::Orphan< ::rlbot::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Vector3> Touch::Builder::disownLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Touch::Reader::hasNormal() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Touch::Builder::hasNormal() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Vector3::Reader Touch::Reader::getNormal() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::rlbot::Vector3::Builder Touch::Builder::getNormal() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Vector3::Pipeline Touch::Pipeline::getNormal() {
  return  ::rlbot::Vector3::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Touch::Builder::setNormal( ::rlbot::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Vector3::Builder Touch::Builder::initNormal() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Touch::Builder::adoptNormal(
    ::capnp::Orphan< ::rlbot::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Vector3> Touch::Builder::disownNormal() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::int32_t ScoreInfo::Reader::getScore() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ScoreInfo::Builder::getScore() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ScoreInfo::Builder::setScore( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ScoreInfo::Reader::getGoals() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ScoreInfo::Builder::getGoals() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ScoreInfo::Builder::setGoals( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ScoreInfo::Reader::getOwnGoals() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ScoreInfo::Builder::getOwnGoals() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void ScoreInfo::Builder::setOwnGoals( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ScoreInfo::Reader::getAssists() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ScoreInfo::Builder::getAssists() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void ScoreInfo::Builder::setAssists( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ScoreInfo::Reader::getSaves() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ScoreInfo::Builder::getSaves() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void ScoreInfo::Builder::setSaves( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ScoreInfo::Reader::getShots() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ScoreInfo::Builder::getShots() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void ScoreInfo::Builder::setShots( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ScoreInfo::Reader::getDemolitions() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ScoreInfo::Builder::getDemolitions() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void ScoreInfo::Builder::setDemolitions( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline bool PlayerInfo::Reader::hasLocation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PlayerInfo::Builder::hasLocation() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Vector3::Reader PlayerInfo::Reader::getLocation() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::rlbot::Vector3::Builder PlayerInfo::Builder::getLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Vector3::Pipeline PlayerInfo::Pipeline::getLocation() {
  return  ::rlbot::Vector3::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PlayerInfo::Builder::setLocation( ::rlbot::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Vector3::Builder PlayerInfo::Builder::initLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PlayerInfo::Builder::adoptLocation(
    ::capnp::Orphan< ::rlbot::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Vector3> PlayerInfo::Builder::disownLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PlayerInfo::Reader::hasRotation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PlayerInfo::Builder::hasRotation() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Rotator::Reader PlayerInfo::Reader::getRotation() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Rotator>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::rlbot::Rotator::Builder PlayerInfo::Builder::getRotation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Rotator>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Rotator::Pipeline PlayerInfo::Pipeline::getRotation() {
  return  ::rlbot::Rotator::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void PlayerInfo::Builder::setRotation( ::rlbot::Rotator::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Rotator>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Rotator::Builder PlayerInfo::Builder::initRotation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Rotator>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PlayerInfo::Builder::adoptRotation(
    ::capnp::Orphan< ::rlbot::Rotator>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Rotator>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Rotator> PlayerInfo::Builder::disownRotation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Rotator>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool PlayerInfo::Reader::hasVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool PlayerInfo::Builder::hasVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Vector3::Reader PlayerInfo::Reader::getVelocity() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::rlbot::Vector3::Builder PlayerInfo::Builder::getVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Vector3::Pipeline PlayerInfo::Pipeline::getVelocity() {
  return  ::rlbot::Vector3::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void PlayerInfo::Builder::setVelocity( ::rlbot::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Vector3::Builder PlayerInfo::Builder::initVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void PlayerInfo::Builder::adoptVelocity(
    ::capnp::Orphan< ::rlbot::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Vector3> PlayerInfo::Builder::disownVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool PlayerInfo::Reader::hasAngularVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool PlayerInfo::Builder::hasAngularVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Vector3::Reader PlayerInfo::Reader::getAngularVelocity() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::rlbot::Vector3::Builder PlayerInfo::Builder::getAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Vector3::Pipeline PlayerInfo::Pipeline::getAngularVelocity() {
  return  ::rlbot::Vector3::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void PlayerInfo::Builder::setAngularVelocity( ::rlbot::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Vector3::Builder PlayerInfo::Builder::initAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void PlayerInfo::Builder::adoptAngularVelocity(
    ::capnp::Orphan< ::rlbot::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Vector3> PlayerInfo::Builder::disownAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool PlayerInfo::Reader::hasScoreInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool PlayerInfo::Builder::hasScoreInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::ScoreInfo::Reader PlayerInfo::Reader::getScoreInfo() const {
  return ::capnp::_::PointerHelpers< ::rlbot::ScoreInfo>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::rlbot::ScoreInfo::Builder PlayerInfo::Builder::getScoreInfo() {
  return ::capnp::_::PointerHelpers< ::rlbot::ScoreInfo>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::ScoreInfo::Pipeline PlayerInfo::Pipeline::getScoreInfo() {
  return  ::rlbot::ScoreInfo::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void PlayerInfo::Builder::setScoreInfo( ::rlbot::ScoreInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::ScoreInfo>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::ScoreInfo::Builder PlayerInfo::Builder::initScoreInfo() {
  return ::capnp::_::PointerHelpers< ::rlbot::ScoreInfo>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void PlayerInfo::Builder::adoptScoreInfo(
    ::capnp::Orphan< ::rlbot::ScoreInfo>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::ScoreInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::ScoreInfo> PlayerInfo::Builder::disownScoreInfo() {
  return ::capnp::_::PointerHelpers< ::rlbot::ScoreInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool PlayerInfo::Reader::getIsDemolished() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool PlayerInfo::Builder::getIsDemolished() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PlayerInfo::Builder::setIsDemolished(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool PlayerInfo::Reader::getIsMidair() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool PlayerInfo::Builder::getIsMidair() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void PlayerInfo::Builder::setIsMidair(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool PlayerInfo::Reader::getIsSupersonic() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline bool PlayerInfo::Builder::getIsSupersonic() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void PlayerInfo::Builder::setIsSupersonic(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool PlayerInfo::Reader::getIsBot() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline bool PlayerInfo::Builder::getIsBot() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void PlayerInfo::Builder::setIsBot(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool PlayerInfo::Reader::getJumped() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline bool PlayerInfo::Builder::getJumped() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void PlayerInfo::Builder::setJumped(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool PlayerInfo::Reader::getDoubleJumped() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline bool PlayerInfo::Builder::getDoubleJumped() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void PlayerInfo::Builder::setDoubleJumped(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline bool PlayerInfo::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool PlayerInfo::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader PlayerInfo::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder PlayerInfo::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void PlayerInfo::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder PlayerInfo::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void PlayerInfo::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> PlayerInfo::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline  ::int32_t PlayerInfo::Reader::getTeam() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t PlayerInfo::Builder::getTeam() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void PlayerInfo::Builder::setTeam( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t PlayerInfo::Reader::getBoost() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t PlayerInfo::Builder::getBoost() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void PlayerInfo::Builder::setBoost( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool BallInfo::Reader::hasLocation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BallInfo::Builder::hasLocation() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Vector3::Reader BallInfo::Reader::getLocation() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::rlbot::Vector3::Builder BallInfo::Builder::getLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Vector3::Pipeline BallInfo::Pipeline::getLocation() {
  return  ::rlbot::Vector3::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BallInfo::Builder::setLocation( ::rlbot::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Vector3::Builder BallInfo::Builder::initLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BallInfo::Builder::adoptLocation(
    ::capnp::Orphan< ::rlbot::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Vector3> BallInfo::Builder::disownLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BallInfo::Reader::hasRotation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BallInfo::Builder::hasRotation() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Rotator::Reader BallInfo::Reader::getRotation() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Rotator>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::rlbot::Rotator::Builder BallInfo::Builder::getRotation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Rotator>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Rotator::Pipeline BallInfo::Pipeline::getRotation() {
  return  ::rlbot::Rotator::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void BallInfo::Builder::setRotation( ::rlbot::Rotator::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Rotator>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Rotator::Builder BallInfo::Builder::initRotation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Rotator>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BallInfo::Builder::adoptRotation(
    ::capnp::Orphan< ::rlbot::Rotator>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Rotator>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Rotator> BallInfo::Builder::disownRotation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Rotator>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool BallInfo::Reader::hasVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool BallInfo::Builder::hasVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Vector3::Reader BallInfo::Reader::getVelocity() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::rlbot::Vector3::Builder BallInfo::Builder::getVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Vector3::Pipeline BallInfo::Pipeline::getVelocity() {
  return  ::rlbot::Vector3::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void BallInfo::Builder::setVelocity( ::rlbot::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Vector3::Builder BallInfo::Builder::initVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void BallInfo::Builder::adoptVelocity(
    ::capnp::Orphan< ::rlbot::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Vector3> BallInfo::Builder::disownVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool BallInfo::Reader::hasAngularVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool BallInfo::Builder::hasAngularVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Vector3::Reader BallInfo::Reader::getAngularVelocity() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::rlbot::Vector3::Builder BallInfo::Builder::getAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Vector3::Pipeline BallInfo::Pipeline::getAngularVelocity() {
  return  ::rlbot::Vector3::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void BallInfo::Builder::setAngularVelocity( ::rlbot::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Vector3::Builder BallInfo::Builder::initAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void BallInfo::Builder::adoptAngularVelocity(
    ::capnp::Orphan< ::rlbot::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Vector3> BallInfo::Builder::disownAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool BallInfo::Reader::hasLatestTouch() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool BallInfo::Builder::hasLatestTouch() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Touch::Reader BallInfo::Reader::getLatestTouch() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Touch>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::rlbot::Touch::Builder BallInfo::Builder::getLatestTouch() {
  return ::capnp::_::PointerHelpers< ::rlbot::Touch>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Touch::Pipeline BallInfo::Pipeline::getLatestTouch() {
  return  ::rlbot::Touch::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void BallInfo::Builder::setLatestTouch( ::rlbot::Touch::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Touch>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Touch::Builder BallInfo::Builder::initLatestTouch() {
  return ::capnp::_::PointerHelpers< ::rlbot::Touch>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void BallInfo::Builder::adoptLatestTouch(
    ::capnp::Orphan< ::rlbot::Touch>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Touch>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Touch> BallInfo::Builder::disownLatestTouch() {
  return ::capnp::_::PointerHelpers< ::rlbot::Touch>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool BoostInfo::Reader::hasLocation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BoostInfo::Builder::hasLocation() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Vector3::Reader BoostInfo::Reader::getLocation() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::rlbot::Vector3::Builder BoostInfo::Builder::getLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Vector3::Pipeline BoostInfo::Pipeline::getLocation() {
  return  ::rlbot::Vector3::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BoostInfo::Builder::setLocation( ::rlbot::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Vector3::Builder BoostInfo::Builder::initLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BoostInfo::Builder::adoptLocation(
    ::capnp::Orphan< ::rlbot::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Vector3> BoostInfo::Builder::disownLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BoostInfo::Reader::getIsActive() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool BoostInfo::Builder::getIsActive() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BoostInfo::Builder::setIsActive(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float BoostInfo::Reader::getTimer() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float BoostInfo::Builder::getTimer() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BoostInfo::Builder::setTimer(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float GameInfo::Reader::getSecondsElapsed() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float GameInfo::Builder::getSecondsElapsed() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GameInfo::Builder::setSecondsElapsed(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float GameInfo::Reader::getGameTimeRemaining() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float GameInfo::Builder::getGameTimeRemaining() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void GameInfo::Builder::setGameTimeRemaining(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool GameInfo::Reader::getIsOvertime() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool GameInfo::Builder::getIsOvertime() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void GameInfo::Builder::setIsOvertime(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline bool GameInfo::Reader::getIsUnlimitedTime() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS);
}

inline bool GameInfo::Builder::getIsUnlimitedTime() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS);
}
inline void GameInfo::Builder::setIsUnlimitedTime(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS, value);
}

inline bool GameInfo::Reader::getIsRoundActive() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS);
}

inline bool GameInfo::Builder::getIsRoundActive() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS);
}
inline void GameInfo::Builder::setIsRoundActive(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS, value);
}

inline bool GameInfo::Reader::getIsKickoffPause() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<67>() * ::capnp::ELEMENTS);
}

inline bool GameInfo::Builder::getIsKickoffPause() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<67>() * ::capnp::ELEMENTS);
}
inline void GameInfo::Builder::setIsKickoffPause(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<67>() * ::capnp::ELEMENTS, value);
}

inline bool GameInfo::Reader::getIsMatchEnded() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<68>() * ::capnp::ELEMENTS);
}

inline bool GameInfo::Builder::getIsMatchEnded() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<68>() * ::capnp::ELEMENTS);
}
inline void GameInfo::Builder::setIsMatchEnded(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<68>() * ::capnp::ELEMENTS, value);
}

inline bool GameTickPacket::Reader::hasPlayers() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GameTickPacket::Builder::hasPlayers() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::rlbot::PlayerInfo>::Reader GameTickPacket::Reader::getPlayers() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::PlayerInfo>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::rlbot::PlayerInfo>::Builder GameTickPacket::Builder::getPlayers() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::PlayerInfo>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GameTickPacket::Builder::setPlayers( ::capnp::List< ::rlbot::PlayerInfo>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::PlayerInfo>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::rlbot::PlayerInfo>::Builder GameTickPacket::Builder::initPlayers(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::PlayerInfo>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void GameTickPacket::Builder::adoptPlayers(
    ::capnp::Orphan< ::capnp::List< ::rlbot::PlayerInfo>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::PlayerInfo>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::rlbot::PlayerInfo>> GameTickPacket::Builder::disownPlayers() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::PlayerInfo>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t GameTickPacket::Reader::getPlayerIndex() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t GameTickPacket::Builder::getPlayerIndex() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GameTickPacket::Builder::setPlayerIndex( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool GameTickPacket::Reader::hasBoostPads() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool GameTickPacket::Builder::hasBoostPads() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::rlbot::BoostInfo>::Reader GameTickPacket::Reader::getBoostPads() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::BoostInfo>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::rlbot::BoostInfo>::Builder GameTickPacket::Builder::getBoostPads() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::BoostInfo>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void GameTickPacket::Builder::setBoostPads( ::capnp::List< ::rlbot::BoostInfo>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::BoostInfo>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::rlbot::BoostInfo>::Builder GameTickPacket::Builder::initBoostPads(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::BoostInfo>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void GameTickPacket::Builder::adoptBoostPads(
    ::capnp::Orphan< ::capnp::List< ::rlbot::BoostInfo>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::BoostInfo>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::rlbot::BoostInfo>> GameTickPacket::Builder::disownBoostPads() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::BoostInfo>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool GameTickPacket::Reader::hasBall() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool GameTickPacket::Builder::hasBall() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::BallInfo::Reader GameTickPacket::Reader::getBall() const {
  return ::capnp::_::PointerHelpers< ::rlbot::BallInfo>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::rlbot::BallInfo::Builder GameTickPacket::Builder::getBall() {
  return ::capnp::_::PointerHelpers< ::rlbot::BallInfo>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::BallInfo::Pipeline GameTickPacket::Pipeline::getBall() {
  return  ::rlbot::BallInfo::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void GameTickPacket::Builder::setBall( ::rlbot::BallInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::BallInfo>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::BallInfo::Builder GameTickPacket::Builder::initBall() {
  return ::capnp::_::PointerHelpers< ::rlbot::BallInfo>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void GameTickPacket::Builder::adoptBall(
    ::capnp::Orphan< ::rlbot::BallInfo>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::BallInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::BallInfo> GameTickPacket::Builder::disownBall() {
  return ::capnp::_::PointerHelpers< ::rlbot::BallInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool GameTickPacket::Reader::hasGameInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool GameTickPacket::Builder::hasGameInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::GameInfo::Reader GameTickPacket::Reader::getGameInfo() const {
  return ::capnp::_::PointerHelpers< ::rlbot::GameInfo>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::rlbot::GameInfo::Builder GameTickPacket::Builder::getGameInfo() {
  return ::capnp::_::PointerHelpers< ::rlbot::GameInfo>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::GameInfo::Pipeline GameTickPacket::Pipeline::getGameInfo() {
  return  ::rlbot::GameInfo::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void GameTickPacket::Builder::setGameInfo( ::rlbot::GameInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::GameInfo>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::GameInfo::Builder GameTickPacket::Builder::initGameInfo() {
  return ::capnp::_::PointerHelpers< ::rlbot::GameInfo>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void GameTickPacket::Builder::adoptGameInfo(
    ::capnp::Orphan< ::rlbot::GameInfo>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::GameInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::GameInfo> GameTickPacket::Builder::disownGameInfo() {
  return ::capnp::_::PointerHelpers< ::rlbot::GameInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline typename Vector3Partial::X::Reader Vector3Partial::Reader::getX() const {
  return typename Vector3Partial::X::Reader(_reader);
}
inline typename Vector3Partial::X::Builder Vector3Partial::Builder::getX() {
  return typename Vector3Partial::X::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Vector3Partial::X::Pipeline Vector3Partial::Pipeline::getX() {
  return typename Vector3Partial::X::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Vector3Partial::X::Builder Vector3Partial::Builder::initX() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  return typename Vector3Partial::X::Builder(_builder);
}
inline typename Vector3Partial::Y::Reader Vector3Partial::Reader::getY() const {
  return typename Vector3Partial::Y::Reader(_reader);
}
inline typename Vector3Partial::Y::Builder Vector3Partial::Builder::getY() {
  return typename Vector3Partial::Y::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Vector3Partial::Y::Pipeline Vector3Partial::Pipeline::getY() {
  return typename Vector3Partial::Y::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Vector3Partial::Y::Builder Vector3Partial::Builder::initY() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  return typename Vector3Partial::Y::Builder(_builder);
}
inline typename Vector3Partial::Z::Reader Vector3Partial::Reader::getZ() const {
  return typename Vector3Partial::Z::Reader(_reader);
}
inline typename Vector3Partial::Z::Builder Vector3Partial::Builder::getZ() {
  return typename Vector3Partial::Z::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Vector3Partial::Z::Pipeline Vector3Partial::Pipeline::getZ() {
  return typename Vector3Partial::Z::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Vector3Partial::Z::Builder Vector3Partial::Builder::initZ() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<6>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<4>() * ::capnp::ELEMENTS, 0);
  return typename Vector3Partial::Z::Builder(_builder);
}
inline  ::rlbot::Vector3Partial::X::Which Vector3Partial::X::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::rlbot::Vector3Partial::X::Which Vector3Partial::X::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Vector3Partial::X::Reader::isUnset() const {
  return which() == Vector3Partial::X::UNSET;
}
inline bool Vector3Partial::X::Builder::isUnset() {
  return which() == Vector3Partial::X::UNSET;
}
inline  ::capnp::Void Vector3Partial::X::Reader::getUnset() const {
  KJ_IREQUIRE((which() == Vector3Partial::X::UNSET),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Vector3Partial::X::Builder::getUnset() {
  KJ_IREQUIRE((which() == Vector3Partial::X::UNSET),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector3Partial::X::Builder::setUnset( ::capnp::Void value) {
  _builder.setDataField<Vector3Partial::X::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Vector3Partial::X::UNSET);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Vector3Partial::X::Reader::isValue() const {
  return which() == Vector3Partial::X::VALUE;
}
inline bool Vector3Partial::X::Builder::isValue() {
  return which() == Vector3Partial::X::VALUE;
}
inline float Vector3Partial::X::Reader::getValue() const {
  KJ_IREQUIRE((which() == Vector3Partial::X::VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Vector3Partial::X::Builder::getValue() {
  KJ_IREQUIRE((which() == Vector3Partial::X::VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Vector3Partial::X::Builder::setValue(float value) {
  _builder.setDataField<Vector3Partial::X::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Vector3Partial::X::VALUE);
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::rlbot::Vector3Partial::Y::Which Vector3Partial::Y::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::rlbot::Vector3Partial::Y::Which Vector3Partial::Y::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool Vector3Partial::Y::Reader::isUnset() const {
  return which() == Vector3Partial::Y::UNSET;
}
inline bool Vector3Partial::Y::Builder::isUnset() {
  return which() == Vector3Partial::Y::UNSET;
}
inline  ::capnp::Void Vector3Partial::Y::Reader::getUnset() const {
  KJ_IREQUIRE((which() == Vector3Partial::Y::UNSET),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Vector3Partial::Y::Builder::getUnset() {
  KJ_IREQUIRE((which() == Vector3Partial::Y::UNSET),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector3Partial::Y::Builder::setUnset( ::capnp::Void value) {
  _builder.setDataField<Vector3Partial::Y::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Vector3Partial::Y::UNSET);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Vector3Partial::Y::Reader::isValue() const {
  return which() == Vector3Partial::Y::VALUE;
}
inline bool Vector3Partial::Y::Builder::isValue() {
  return which() == Vector3Partial::Y::VALUE;
}
inline float Vector3Partial::Y::Reader::getValue() const {
  KJ_IREQUIRE((which() == Vector3Partial::Y::VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Vector3Partial::Y::Builder::getValue() {
  KJ_IREQUIRE((which() == Vector3Partial::Y::VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Vector3Partial::Y::Builder::setValue(float value) {
  _builder.setDataField<Vector3Partial::Y::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Vector3Partial::Y::VALUE);
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::rlbot::Vector3Partial::Z::Which Vector3Partial::Z::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline  ::rlbot::Vector3Partial::Z::Which Vector3Partial::Z::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline bool Vector3Partial::Z::Reader::isUnset() const {
  return which() == Vector3Partial::Z::UNSET;
}
inline bool Vector3Partial::Z::Builder::isUnset() {
  return which() == Vector3Partial::Z::UNSET;
}
inline  ::capnp::Void Vector3Partial::Z::Reader::getUnset() const {
  KJ_IREQUIRE((which() == Vector3Partial::Z::UNSET),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Vector3Partial::Z::Builder::getUnset() {
  KJ_IREQUIRE((which() == Vector3Partial::Z::UNSET),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector3Partial::Z::Builder::setUnset( ::capnp::Void value) {
  _builder.setDataField<Vector3Partial::Z::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, Vector3Partial::Z::UNSET);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Vector3Partial::Z::Reader::isValue() const {
  return which() == Vector3Partial::Z::VALUE;
}
inline bool Vector3Partial::Z::Builder::isValue() {
  return which() == Vector3Partial::Z::VALUE;
}
inline float Vector3Partial::Z::Reader::getValue() const {
  KJ_IREQUIRE((which() == Vector3Partial::Z::VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float Vector3Partial::Z::Builder::getValue() {
  KJ_IREQUIRE((which() == Vector3Partial::Z::VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Vector3Partial::Z::Builder::setValue(float value) {
  _builder.setDataField<Vector3Partial::Z::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, Vector3Partial::Z::VALUE);
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline typename RotatorPartial::Pitch::Reader RotatorPartial::Reader::getPitch() const {
  return typename RotatorPartial::Pitch::Reader(_reader);
}
inline typename RotatorPartial::Pitch::Builder RotatorPartial::Builder::getPitch() {
  return typename RotatorPartial::Pitch::Builder(_builder);
}
#if !CAPNP_LITE
inline typename RotatorPartial::Pitch::Pipeline RotatorPartial::Pipeline::getPitch() {
  return typename RotatorPartial::Pitch::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename RotatorPartial::Pitch::Builder RotatorPartial::Builder::initPitch() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  return typename RotatorPartial::Pitch::Builder(_builder);
}
inline typename RotatorPartial::Yaw::Reader RotatorPartial::Reader::getYaw() const {
  return typename RotatorPartial::Yaw::Reader(_reader);
}
inline typename RotatorPartial::Yaw::Builder RotatorPartial::Builder::getYaw() {
  return typename RotatorPartial::Yaw::Builder(_builder);
}
#if !CAPNP_LITE
inline typename RotatorPartial::Yaw::Pipeline RotatorPartial::Pipeline::getYaw() {
  return typename RotatorPartial::Yaw::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename RotatorPartial::Yaw::Builder RotatorPartial::Builder::initYaw() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  return typename RotatorPartial::Yaw::Builder(_builder);
}
inline typename RotatorPartial::Roll::Reader RotatorPartial::Reader::getRoll() const {
  return typename RotatorPartial::Roll::Reader(_reader);
}
inline typename RotatorPartial::Roll::Builder RotatorPartial::Builder::getRoll() {
  return typename RotatorPartial::Roll::Builder(_builder);
}
#if !CAPNP_LITE
inline typename RotatorPartial::Roll::Pipeline RotatorPartial::Pipeline::getRoll() {
  return typename RotatorPartial::Roll::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename RotatorPartial::Roll::Builder RotatorPartial::Builder::initRoll() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<6>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<4>() * ::capnp::ELEMENTS, 0);
  return typename RotatorPartial::Roll::Builder(_builder);
}
inline  ::rlbot::RotatorPartial::Pitch::Which RotatorPartial::Pitch::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::rlbot::RotatorPartial::Pitch::Which RotatorPartial::Pitch::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool RotatorPartial::Pitch::Reader::isUnset() const {
  return which() == RotatorPartial::Pitch::UNSET;
}
inline bool RotatorPartial::Pitch::Builder::isUnset() {
  return which() == RotatorPartial::Pitch::UNSET;
}
inline  ::capnp::Void RotatorPartial::Pitch::Reader::getUnset() const {
  KJ_IREQUIRE((which() == RotatorPartial::Pitch::UNSET),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void RotatorPartial::Pitch::Builder::getUnset() {
  KJ_IREQUIRE((which() == RotatorPartial::Pitch::UNSET),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RotatorPartial::Pitch::Builder::setUnset( ::capnp::Void value) {
  _builder.setDataField<RotatorPartial::Pitch::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, RotatorPartial::Pitch::UNSET);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool RotatorPartial::Pitch::Reader::isValue() const {
  return which() == RotatorPartial::Pitch::VALUE;
}
inline bool RotatorPartial::Pitch::Builder::isValue() {
  return which() == RotatorPartial::Pitch::VALUE;
}
inline float RotatorPartial::Pitch::Reader::getValue() const {
  KJ_IREQUIRE((which() == RotatorPartial::Pitch::VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float RotatorPartial::Pitch::Builder::getValue() {
  KJ_IREQUIRE((which() == RotatorPartial::Pitch::VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RotatorPartial::Pitch::Builder::setValue(float value) {
  _builder.setDataField<RotatorPartial::Pitch::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, RotatorPartial::Pitch::VALUE);
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::rlbot::RotatorPartial::Yaw::Which RotatorPartial::Yaw::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::rlbot::RotatorPartial::Yaw::Which RotatorPartial::Yaw::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool RotatorPartial::Yaw::Reader::isUnset() const {
  return which() == RotatorPartial::Yaw::UNSET;
}
inline bool RotatorPartial::Yaw::Builder::isUnset() {
  return which() == RotatorPartial::Yaw::UNSET;
}
inline  ::capnp::Void RotatorPartial::Yaw::Reader::getUnset() const {
  KJ_IREQUIRE((which() == RotatorPartial::Yaw::UNSET),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void RotatorPartial::Yaw::Builder::getUnset() {
  KJ_IREQUIRE((which() == RotatorPartial::Yaw::UNSET),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RotatorPartial::Yaw::Builder::setUnset( ::capnp::Void value) {
  _builder.setDataField<RotatorPartial::Yaw::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, RotatorPartial::Yaw::UNSET);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool RotatorPartial::Yaw::Reader::isValue() const {
  return which() == RotatorPartial::Yaw::VALUE;
}
inline bool RotatorPartial::Yaw::Builder::isValue() {
  return which() == RotatorPartial::Yaw::VALUE;
}
inline float RotatorPartial::Yaw::Reader::getValue() const {
  KJ_IREQUIRE((which() == RotatorPartial::Yaw::VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float RotatorPartial::Yaw::Builder::getValue() {
  KJ_IREQUIRE((which() == RotatorPartial::Yaw::VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void RotatorPartial::Yaw::Builder::setValue(float value) {
  _builder.setDataField<RotatorPartial::Yaw::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, RotatorPartial::Yaw::VALUE);
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::rlbot::RotatorPartial::Roll::Which RotatorPartial::Roll::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline  ::rlbot::RotatorPartial::Roll::Which RotatorPartial::Roll::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline bool RotatorPartial::Roll::Reader::isUnset() const {
  return which() == RotatorPartial::Roll::UNSET;
}
inline bool RotatorPartial::Roll::Builder::isUnset() {
  return which() == RotatorPartial::Roll::UNSET;
}
inline  ::capnp::Void RotatorPartial::Roll::Reader::getUnset() const {
  KJ_IREQUIRE((which() == RotatorPartial::Roll::UNSET),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void RotatorPartial::Roll::Builder::getUnset() {
  KJ_IREQUIRE((which() == RotatorPartial::Roll::UNSET),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RotatorPartial::Roll::Builder::setUnset( ::capnp::Void value) {
  _builder.setDataField<RotatorPartial::Roll::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, RotatorPartial::Roll::UNSET);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool RotatorPartial::Roll::Reader::isValue() const {
  return which() == RotatorPartial::Roll::VALUE;
}
inline bool RotatorPartial::Roll::Builder::isValue() {
  return which() == RotatorPartial::Roll::VALUE;
}
inline float RotatorPartial::Roll::Reader::getValue() const {
  KJ_IREQUIRE((which() == RotatorPartial::Roll::VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float RotatorPartial::Roll::Builder::getValue() {
  KJ_IREQUIRE((which() == RotatorPartial::Roll::VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void RotatorPartial::Roll::Builder::setValue(float value) {
  _builder.setDataField<RotatorPartial::Roll::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, RotatorPartial::Roll::VALUE);
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool DesiredPhysics::Reader::hasLocation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool DesiredPhysics::Builder::hasLocation() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Vector3Partial::Reader DesiredPhysics::Reader::getLocation() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::rlbot::Vector3Partial::Builder DesiredPhysics::Builder::getLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Vector3Partial::Pipeline DesiredPhysics::Pipeline::getLocation() {
  return  ::rlbot::Vector3Partial::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void DesiredPhysics::Builder::setLocation( ::rlbot::Vector3Partial::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Vector3Partial::Builder DesiredPhysics::Builder::initLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void DesiredPhysics::Builder::adoptLocation(
    ::capnp::Orphan< ::rlbot::Vector3Partial>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Vector3Partial> DesiredPhysics::Builder::disownLocation() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool DesiredPhysics::Reader::hasRotation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool DesiredPhysics::Builder::hasRotation() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::RotatorPartial::Reader DesiredPhysics::Reader::getRotation() const {
  return ::capnp::_::PointerHelpers< ::rlbot::RotatorPartial>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::rlbot::RotatorPartial::Builder DesiredPhysics::Builder::getRotation() {
  return ::capnp::_::PointerHelpers< ::rlbot::RotatorPartial>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::RotatorPartial::Pipeline DesiredPhysics::Pipeline::getRotation() {
  return  ::rlbot::RotatorPartial::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void DesiredPhysics::Builder::setRotation( ::rlbot::RotatorPartial::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::RotatorPartial>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::RotatorPartial::Builder DesiredPhysics::Builder::initRotation() {
  return ::capnp::_::PointerHelpers< ::rlbot::RotatorPartial>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void DesiredPhysics::Builder::adoptRotation(
    ::capnp::Orphan< ::rlbot::RotatorPartial>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::RotatorPartial>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::RotatorPartial> DesiredPhysics::Builder::disownRotation() {
  return ::capnp::_::PointerHelpers< ::rlbot::RotatorPartial>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool DesiredPhysics::Reader::hasVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool DesiredPhysics::Builder::hasVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Vector3Partial::Reader DesiredPhysics::Reader::getVelocity() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::rlbot::Vector3Partial::Builder DesiredPhysics::Builder::getVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Vector3Partial::Pipeline DesiredPhysics::Pipeline::getVelocity() {
  return  ::rlbot::Vector3Partial::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void DesiredPhysics::Builder::setVelocity( ::rlbot::Vector3Partial::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Vector3Partial::Builder DesiredPhysics::Builder::initVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void DesiredPhysics::Builder::adoptVelocity(
    ::capnp::Orphan< ::rlbot::Vector3Partial>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Vector3Partial> DesiredPhysics::Builder::disownVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool DesiredPhysics::Reader::hasAngularVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool DesiredPhysics::Builder::hasAngularVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::Vector3Partial::Reader DesiredPhysics::Reader::getAngularVelocity() const {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::rlbot::Vector3Partial::Builder DesiredPhysics::Builder::getAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::Vector3Partial::Pipeline DesiredPhysics::Pipeline::getAngularVelocity() {
  return  ::rlbot::Vector3Partial::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void DesiredPhysics::Builder::setAngularVelocity( ::rlbot::Vector3Partial::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::Vector3Partial::Builder DesiredPhysics::Builder::initAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void DesiredPhysics::Builder::adoptAngularVelocity(
    ::capnp::Orphan< ::rlbot::Vector3Partial>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::Vector3Partial> DesiredPhysics::Builder::disownAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::rlbot::Vector3Partial>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool DesiredBallState::Reader::hasPhysics() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool DesiredBallState::Builder::hasPhysics() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::DesiredPhysics::Reader DesiredBallState::Reader::getPhysics() const {
  return ::capnp::_::PointerHelpers< ::rlbot::DesiredPhysics>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::rlbot::DesiredPhysics::Builder DesiredBallState::Builder::getPhysics() {
  return ::capnp::_::PointerHelpers< ::rlbot::DesiredPhysics>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::DesiredPhysics::Pipeline DesiredBallState::Pipeline::getPhysics() {
  return  ::rlbot::DesiredPhysics::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void DesiredBallState::Builder::setPhysics( ::rlbot::DesiredPhysics::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::DesiredPhysics>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::DesiredPhysics::Builder DesiredBallState::Builder::initPhysics() {
  return ::capnp::_::PointerHelpers< ::rlbot::DesiredPhysics>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void DesiredBallState::Builder::adoptPhysics(
    ::capnp::Orphan< ::rlbot::DesiredPhysics>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::DesiredPhysics>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::DesiredPhysics> DesiredBallState::Builder::disownPhysics() {
  return ::capnp::_::PointerHelpers< ::rlbot::DesiredPhysics>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool DesiredCarState::Reader::hasPhysics() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool DesiredCarState::Builder::hasPhysics() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::DesiredPhysics::Reader DesiredCarState::Reader::getPhysics() const {
  return ::capnp::_::PointerHelpers< ::rlbot::DesiredPhysics>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::rlbot::DesiredPhysics::Builder DesiredCarState::Builder::getPhysics() {
  return ::capnp::_::PointerHelpers< ::rlbot::DesiredPhysics>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::DesiredPhysics::Pipeline DesiredCarState::Pipeline::getPhysics() {
  return  ::rlbot::DesiredPhysics::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void DesiredCarState::Builder::setPhysics( ::rlbot::DesiredPhysics::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::DesiredPhysics>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::DesiredPhysics::Builder DesiredCarState::Builder::initPhysics() {
  return ::capnp::_::PointerHelpers< ::rlbot::DesiredPhysics>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void DesiredCarState::Builder::adoptPhysics(
    ::capnp::Orphan< ::rlbot::DesiredPhysics>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::DesiredPhysics>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::DesiredPhysics> DesiredCarState::Builder::disownPhysics() {
  return ::capnp::_::PointerHelpers< ::rlbot::DesiredPhysics>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool DesiredGameState::Reader::hasBallState() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool DesiredGameState::Builder::hasBallState() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::rlbot::DesiredBallState::Reader DesiredGameState::Reader::getBallState() const {
  return ::capnp::_::PointerHelpers< ::rlbot::DesiredBallState>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::rlbot::DesiredBallState::Builder DesiredGameState::Builder::getBallState() {
  return ::capnp::_::PointerHelpers< ::rlbot::DesiredBallState>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::rlbot::DesiredBallState::Pipeline DesiredGameState::Pipeline::getBallState() {
  return  ::rlbot::DesiredBallState::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void DesiredGameState::Builder::setBallState( ::rlbot::DesiredBallState::Reader value) {
  ::capnp::_::PointerHelpers< ::rlbot::DesiredBallState>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::rlbot::DesiredBallState::Builder DesiredGameState::Builder::initBallState() {
  return ::capnp::_::PointerHelpers< ::rlbot::DesiredBallState>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void DesiredGameState::Builder::adoptBallState(
    ::capnp::Orphan< ::rlbot::DesiredBallState>&& value) {
  ::capnp::_::PointerHelpers< ::rlbot::DesiredBallState>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::rlbot::DesiredBallState> DesiredGameState::Builder::disownBallState() {
  return ::capnp::_::PointerHelpers< ::rlbot::DesiredBallState>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool DesiredGameState::Reader::hasCarSates() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool DesiredGameState::Builder::hasCarSates() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::rlbot::DesiredCarState>::Reader DesiredGameState::Reader::getCarSates() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::DesiredCarState>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::rlbot::DesiredCarState>::Builder DesiredGameState::Builder::getCarSates() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::DesiredCarState>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void DesiredGameState::Builder::setCarSates( ::capnp::List< ::rlbot::DesiredCarState>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::DesiredCarState>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::rlbot::DesiredCarState>::Builder DesiredGameState::Builder::initCarSates(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::DesiredCarState>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void DesiredGameState::Builder::adoptCarSates(
    ::capnp::Orphan< ::capnp::List< ::rlbot::DesiredCarState>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::DesiredCarState>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::rlbot::DesiredCarState>> DesiredGameState::Builder::disownCarSates() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::rlbot::DesiredCarState>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

}  // namespace

#endif  // CAPNP_INCLUDED_cb4ac4a4827ed032_
