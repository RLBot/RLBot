group 'rlbotofficial'
version '0.0.1'

import io.netifi.flatbuffers.plugin.tasks.FlatBuffers

buildscript {
    repositories {
        jcenter()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.4'
        classpath "gradle.plugin.io.netifi:gradle-flatbuffers-plugin:1.0.4"
    }
}

apply plugin: 'java'  // This is the backbone of the gradle build process, we don't just use it for java files.
apply plugin: 'com.google.protobuf'
apply plugin: 'maven-publish'  // Needed to get jitpack to work.
apply plugin: "io.netifi.flatbuffers"

repositories {
    jcenter()
}

dependencies {
    compile group: 'net.java.dev.jna', name: 'jna', version: '4.5.1'  // Allows the java bot manager to communicate with dll
    compile group: 'net.java.dev.jna', name: 'jna-platform', version: '4.5.1'  // Allows the java bot manager to communicate with dll
    compile group: 'com.google.protobuf', name: 'protobuf-java', version: '3.1.0'  // Allows the java bot manager to use protobuf
    compile 'org.capnproto:runtime:0.1.3' // Allows java bot manager to use capnproto
    compile group: 'net.sf.py4j', name: 'py4j', version: '0.10.6'  // Allows the java bot manager to accept commands from python.
    compile 'com.github.davidmoten:flatbuffers-java:1.9.0.1'  // Temporarily using this guy's flatbuffers package because the official one is behind.
    testRuntime files('src/main/python/RLBotFramework/dll')
}

def pythonRoot = './src/main/python/'
def protoVersion = '2.6.1'


protobuf {
    // Configure the protoc executable
    protoc {
        // Download from repositories
        artifact = 'com.google.protobuf:protoc:' + protoVersion
    }
    generateProtoTasks {
        // all() returns the collection of all protoc tasks
        all().each {
            task ->
                task.builtins {
                    python { }
                    cpp {}
                    java {}
                }
        }
    }
}

sourceSets {
    main {
        java {
            // This is the default location where java protobuf classes are generated
            srcDirs = ['src/main/java', 'build/generated/source/proto/main/java', 'src/generated/java/flatbuffers']
        }
    }
}

// Runs the capnproto generate script to create java and c++ files.
task generateCapnproto(type: Exec) {
    commandLine "./src/main/capnp/generate.bat"
}

// Copies capnproto java files to where they need to go.
task copyCapnpJava(type: Copy) {
    dependsOn 'generateCapnproto'
    from file('src/main/capnp/Capnp.java')
    into 'build/generated/source/proto/main/java/rlbot'
}

// Copies capnproto c++ files to where they need to go.
task copyCapnpCpp(type: Copy) {
    dependsOn 'generateCapnproto'
    from files('src/main/capnp/game_data.capnp.c++', 'src/main/capnp/game_data.capnp.h')
    into 'build/generated/source/proto/main/cpp'
    rename('game_data.capnp.c\\+\\+', 'game_data.capnp.cpp')
}

// Clears out intermediate files
task deleteCapnp(type: Delete) {
    delete 'src/main/capnp/game_data.capnp.c++', 'src/main/capnp/game_data.capnp.h', 'src/main/capnp/Capnp.java'
}

// Sends all the capnproto files to where they need to go.
task assembleCapnp(dependsOn: ['generateCapnproto', 'copyCapnpJava', 'copyCapnpCpp', 'deleteCapnp']) {
    dependsOn 'copyCapnpJava'
    dependsOn 'copyCapnpCpp'
    dependsOn 'deleteCapnp'
    tasks.findByName('deleteCapnp').mustRunAfter 'copyCapnpCpp'
    tasks.findByName('deleteCapnp').mustRunAfter 'copyCapnpJava'

}

// After protobuf is generated, copy the generated file to its home in the python folder.
task copyProtoPython(type: Copy) {
    dependsOn 'generateProto'
    from file('build/generated/source/proto/main/python/game_data_pb2.py')
    into pythonRoot + 'protobuf'
}

// After protobuf is generated, copy the generated file to its home in the python folder.
task copyFlatbuffersPython(type: Copy) {
    dependsOn 'generateFlatbuffersPython'
    from fileTree('src/generated/python/flatbuffers/rlbot')
    into pythonRoot + 'RLBotMessages'
}

flatbuffers {
    flatcPath = 'src/main/flatbuffers'
}

task generateFlatbuffersJava(type: FlatBuffers) {
    inputDir = file("src/main/flatbuffers")
    outputDir = file("src/generated/java/flatbuffers")
    language = 'java'
}

task generateFlatbuffersPython(type: FlatBuffers) {
    inputDir = file("src/main/flatbuffers")
    outputDir = file("src/generated/python/flatbuffers")
    language = 'python'
}

task generateFlatbuffersCpp(type: FlatBuffers) {
    inputDir = file("src/main/flatbuffers")
    outputDir = file("src/generated/cpp/flatbuffers")
    language = 'cpp'
}

// Useful standalone task for setting up visual studio development environment
task assembleProtos {
    dependsOn 'copyProtoPython'
    dependsOn 'assembleCapnp'
    dependsOn 'copyFlatbuffersPython'
    dependsOn 'generateFlatbuffersJava'
    dependsOn 'generateFlatbuffersCpp'
}

// This is just a convenience task for developers.
task copyDlls(type: Copy) {
    from files('src/main/cpp/RLBotInterface/RLBotInterface/Bin/x64/Debug/RLBotInterface.dll',
            '../rlbot-core/RLBot Core/Bin/Win32/Debug-SDK/RLBot Core.dll')
    into pythonRoot + 'RLBotFramework/dll'
    rename('RLBot Core.dll', 'RLBot_Core.dll')
    rename('RLBotInterface.dll', 'RLBot_Core_Interface.dll')
}

// You can use the clean task to remove build output.
clean {
    // In addition to the normal clean behavior, also remove the generated protobuf python file(s).
    delete pythonRoot + 'protobuf'
    delete pythonRoot + 'RLBotMessages/flat'
    delete 'src/generated'
}

// Use pip, which is the python package manager, to install all requirements listed in requirements.txt.
// Python and pip must already be installed for this to work.
task pipInstallRequirements(type: Exec) {
    commandLine "pip", "install", "-r", pythonRoot + "requirements.txt"
}

// Establish some task dependencies so that some tasks always run before others.
compileJava.dependsOn assembleProtos


// This task creates a jar file which contains the java source files.
task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

// Parses a .gitignore file and attempts to build a list of file paths that can be used by gradle.
def gitignoreToList(File f) {
    def ignores = []
    f.eachLine { line ->
        //ignore comments and empty lines
        if (!line.startsWith('#') && !line.isEmpty()) {
            ignores.add(line)
        }
    }
    return ignores
}

// Creates a zip file with all the python files needed for running rlbot. Custom bot repositories should be able to
// depend on this zip instead of keeping a local copy of framework files.
task pythonZip(type: Zip, dependsOn: processResources) {
    into('/') {
        from(fileTree('src/main/python/'))   // Grab all the files in the src/main/python folder and add them at the root level
        from 'LICENSE.txt'   // Also grab the license
        exclude gitignoreToList(file('.gitignore'))  // Avoid putting any git-ignored files in the zip
        exclude '**/__pycache__'   // Explicitly exclude __pycache__ folders because the gitignoreToList trick doesn't cover this
    }
}

// This is associated with the maven-publish plugin. It's needed for jitpack to work properly.
publishing {
    publications {
        Main(MavenPublication) {
            from components.java
            artifact sourcesJar
            artifact (pythonZip) {
                classifier = 'python'
            }
            groupId group
            artifactId 'RLBotFramework'
            version version
        }
    }
}
